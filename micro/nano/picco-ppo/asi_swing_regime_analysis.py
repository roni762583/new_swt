# -*- coding: utf-8 -*-
"""asi_swing_regime_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14U0ZrXtS05ekuvhxo45JucYqk3iMxDI7
"""

# Install required packages if not already installed
import subprocess
import sys

def install_package(package):
    subprocess.check_call([sys.executable, "-m", "pip", "install", package])

# Check and install required packages
required_packages = ['numpy', 'pandas', 'matplotlib']

for package in required_packages:
    try:
        __import__(package)
        print(f"{package} is already installed")
    except ImportError:
        print(f"Installing {package}...")
        install_package(package)

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib.widgets import Slider, CheckButtons, Cursor, Button
import pandas as pd
from datetime import datetime, timedelta
from IPython.display import display
# %matplotlib inline
plt.rcParams['figure.figsize'] = [12, 8]
plt.rcParams['figure.dpi'] = 100

def generate_synthetic_ohlc(n_bars=500, trend_prob=0.7, volatility=0.001):
    """Generate synthetic OHLC data with trending behavior."""
    np.random.seed(42)

    dates = [datetime.now() - timedelta(hours=i) for i in range(n_bars)][::-1]

    # Start price
    price = 1.0
    trend = 1

    opens, highs, lows, closes = [], [], [], []

    for i in range(n_bars):
        # Occasionally change trend
        if np.random.random() > trend_prob:
            trend *= -1

        # Generate bar
        open_price = price

        # Trend component + random walk
        change = trend * volatility * np.random.random() + (np.random.random() - 0.5) * volatility * 2
        close_price = open_price * (1 + change)

        # High and low
        intrabar_vol = volatility * np.random.random()
        high_price = max(open_price, close_price) * (1 + intrabar_vol * np.random.random())
        low_price = min(open_price, close_price) * (1 - intrabar_vol * np.random.random())

        opens.append(open_price)
        highs.append(high_price)
        lows.append(low_price)
        closes.append(close_price)

        price = close_price

    return pd.DataFrame({
        'Open': opens,
        'High': highs,
        'Low': lows,
        'Close': closes
    }, index=pd.DatetimeIndex(dates))

# Generate data
df = generate_synthetic_ohlc(n_bars=500)
print(f"Generated {len(df)} OHLC bars")
df.head()

def calculate_swing_index(df):
    """
    Calculate Swing Index (SI) for forex markets (without K/L factor).
    Based on Wilder's formula adapted for forex.
    """
    si_values = [0]  # First SI is 0

    for i in range(1, len(df)):
        # Current and previous values
        c1, c2 = df['Close'].iloc[i-1], df['Close'].iloc[i]
        o1, o2 = df['Open'].iloc[i-1], df['Open'].iloc[i]
        h1, h2 = df['High'].iloc[i-1], df['High'].iloc[i]
        l1, l2 = df['Low'].iloc[i-1], df['Low'].iloc[i]

        # Calculate R (complex formula from Wilder)
        # First determine which formula to use
        diff_hc = abs(h2 - c1)
        diff_lc = abs(l2 - c1)
        diff_hl = abs(h2 - l2)

        k = max(diff_hc, diff_lc)

        if diff_hc >= diff_lc and diff_hc >= diff_hl:
            r = diff_hc - 0.5 * diff_lc + 0.25 * abs(c1 - o1)
        elif diff_lc >= diff_hc and diff_lc >= diff_hl:
            r = diff_lc - 0.5 * diff_hc + 0.25 * abs(c1 - o1)
        else:
            r = diff_hl + 0.25 * abs(c1 - o1)

        # Prevent division by zero
        if r == 0:
            si = 0
        else:
            # SI formula for forex (no K/L factor)
            si = 50 * ((c2 - c1 + 0.5 * (c2 - o2) + 0.25 * (c1 - o1)) / r)

        si_values.append(si)

    # Calculate ASI (cumulative sum)
    asi_values = np.cumsum(si_values)

    return si_values, asi_values

# Calculate SI and ASI
si_values, asi_values = calculate_swing_index(df)
print(f"Calculated {len(si_values)} SI values")
print(f"ASI range: {np.min(asi_values):.2f} to {np.max(asi_values):.2f}")

def detect_swing_points(asi_values, min_distance=1, confirmation_bars=1):
    """
    Detect High Swing Points (HSP) and Low Swing Points (LSP) in ASI.
    HSP: ASI[i] is higher than confirmation_bars on each side
    LSP: ASI[i] is lower than confirmation_bars on each side

    Args:
        asi_values: Array of ASI values
        min_distance: Minimum number of bars between swing points
        confirmation_bars: Number of bars on each side that must be lower/higher
    """
    # First, find all potential swing points
    potential_hsp = []
    potential_lsp = []

    # Need enough bars on each side for confirmation
    for i in range(confirmation_bars, len(asi_values) - confirmation_bars):
        # Check if it's a high swing point
        is_high_swing = True
        for j in range(1, confirmation_bars + 1):
            if asi_values[i] <= asi_values[i-j] or asi_values[i] <= asi_values[i+j]:
                is_high_swing = False
                break

        # Check if it's a low swing point
        is_low_swing = True
        for j in range(1, confirmation_bars + 1):
            if asi_values[i] >= asi_values[i-j] or asi_values[i] >= asi_values[i+j]:
                is_low_swing = False
                break

        if is_high_swing:
            potential_hsp.append((i, asi_values[i]))
        elif is_low_swing:
            potential_lsp.append((i, asi_values[i]))

    # Filter by minimum distance, keeping most extreme values
    hsp_indices = filter_swing_points_by_distance(potential_hsp, min_distance, is_high=True)
    lsp_indices = filter_swing_points_by_distance(potential_lsp, min_distance, is_high=False)

    # Enforce alternation to prevent regime overlaps
    hsp_indices, lsp_indices = enforce_alternating_swings(hsp_indices, lsp_indices, asi_values)

    return hsp_indices, lsp_indices


def enforce_alternating_swings(hsp_indices, lsp_indices, asi_values):
    """
    Ensure swing points alternate between highs and lows.
    When multiple same-type swings occur in sequence, keep only the most extreme.
    """
    if not hsp_indices and not lsp_indices:
        return [], []

    # Combine all swings with their type and sort by index
    all_swings = []
    for idx in hsp_indices:
        all_swings.append((idx, 'H', asi_values[idx]))
    for idx in lsp_indices:
        all_swings.append((idx, 'L', asi_values[idx]))

    # Sort by chronological order
    all_swings.sort(key=lambda x: x[0])

    # Enforce alternation
    filtered_swings = []
    last_type = None
    current_group = []

    for swing in all_swings:
        idx, swing_type, value = swing

        if swing_type == last_type:
            # Same type as previous - add to group
            current_group.append(swing)
        else:
            # Different type - process previous group if exists
            if current_group:
                if last_type == 'H':
                    # Keep highest of the group
                    best = max(current_group, key=lambda x: x[2])
                else:
                    # Keep lowest of the group
                    best = min(current_group, key=lambda x: x[2])
                filtered_swings.append(best)

            # Start new group
            current_group = [swing]
            last_type = swing_type

    # Don't forget the last group
    if current_group:
        if last_type == 'H':
            best = max(current_group, key=lambda x: x[2])
        else:
            best = min(current_group, key=lambda x: x[2])
        filtered_swings.append(best)

    # Separate back into HSP and LSP
    final_hsp = [s[0] for s in filtered_swings if s[1] == 'H']
    final_lsp = [s[0] for s in filtered_swings if s[1] == 'L']

    return final_hsp, final_lsp


def filter_swing_points_by_distance(swing_points, min_distance, is_high=True):
    """
    Filter swing points to ensure minimum distance between them.
    Keep the most extreme values when points are too close.
    """
    if not swing_points or min_distance <= 1:
        return [sp[0] for sp in swing_points]

    filtered = []
    i = 0

    while i < len(swing_points):
        # Find all points within min_distance
        group = [swing_points[i]]
        j = i + 1

        while j < len(swing_points) and swing_points[j][0] - swing_points[i][0] < min_distance:
            group.append(swing_points[j])
            j += 1

        # Select the most extreme point from the group
        if is_high:
            # For high swing points, select the highest
            best = max(group, key=lambda x: x[1])
        else:
            # For low swing points, select the lowest
            best = min(group, key=lambda x: x[1])

        filtered.append(best[0])

        # Move to the next group
        i = j

    return filtered

def filter_by_exceeding_extremes(hsp_indices, lsp_indices, asi_values):
    """
    Filter swing points using intelligent exceeding extremes logic.
    When a new extreme is made on one side, it resets the requirement for the opposite side.
    """
    if not hsp_indices and not lsp_indices:
        return [], []

    # Combine all swing points with their type
    all_swings = []
    for idx in hsp_indices:
        all_swings.append((idx, 'high', asi_values[idx]))
    for idx in lsp_indices:
        all_swings.append((idx, 'low', asi_values[idx]))

    # Sort by index (time order)
    all_swings.sort(key=lambda x: x[0])

    if not all_swings:
        return [], []

    # Process swings in chronological order
    filtered_hsp = []
    filtered_lsp = []

    # Initialize with first swing
    last_high_extreme = None
    last_low_extreme = None
    last_high_idx = None
    last_low_idx = None

    for idx, swing_type, value in all_swings:
        if swing_type == 'high':
            # First high or exceeds previous extreme high
            if last_high_extreme is None or value > last_high_extreme:
                filtered_hsp.append(idx)
                last_high_extreme = value
                last_high_idx = idx
                # Reset low requirement - next low can be any swing low
                last_low_idx = None
            # Or if we've made a new low extreme since the last high
            elif last_low_idx is not None and (last_high_idx is None or last_low_idx > last_high_idx):
                filtered_hsp.append(idx)
                last_high_idx = idx

        else:  # swing_type == 'low'
            # First low or exceeds previous extreme low
            if last_low_extreme is None or value < last_low_extreme:
                filtered_lsp.append(idx)
                last_low_extreme = value
                last_low_idx = idx
                # Reset high requirement - next high can be any swing high
                last_high_idx = None
            # Or if we've made a new high extreme since the last low
            elif last_high_idx is not None and (last_low_idx is None or last_high_idx > last_low_idx):
                filtered_lsp.append(idx)
                last_low_idx = idx

    return filtered_hsp, filtered_lsp

def calculate_asi_swing_pattern_regime_with_filtered_points(asi_values, hsp_indices, lsp_indices, lookback=200):
    """
    Calculate swing pattern regime based on pre-filtered ASI swing points.
    Returns time series of one-hot encoded regimes.
    """
    n = len(asi_values)
    regimes = {
        'swing_regime_uptrend': np.zeros(n),
        'swing_regime_downtrend': np.zeros(n),
        'swing_regime_bullish_divergence': np.zeros(n),
        'swing_regime_bearish_divergence': np.zeros(n)
    }

    # Need at least 2 highs and 2 lows
    if len(hsp_indices) < 2 or len(lsp_indices) < 2:
        return regimes

    # Determine regime at each point
    for i in range(n):
        # Find the most recent 2 swing highs and lows before position i
        recent_highs = [idx for idx in hsp_indices if idx <= i][-2:]
        recent_lows = [idx for idx in lsp_indices if idx <= i][-2:]

        if len(recent_highs) == 2 and len(recent_lows) == 2:
            # Get values
            recent_high = asi_values[recent_highs[-1]]
            prev_high = asi_values[recent_highs[-2]]
            recent_low = asi_values[recent_lows[-1]]
            prev_low = asi_values[recent_lows[-2]]

            # Determine patterns
            higher_highs = recent_high > prev_high
            higher_lows = recent_low > prev_low

            # Classify regime
            if higher_highs and higher_lows:
                regimes['swing_regime_uptrend'][i] = 1  # HH & HL
            elif not higher_highs and not higher_lows:
                regimes['swing_regime_downtrend'][i] = 1  # LH & LL
            elif higher_highs and not higher_lows:
                regimes['swing_regime_bullish_divergence'][i] = 1  # HH & LL
            else:  # not higher_highs and higher_lows
                regimes['swing_regime_bearish_divergence'][i] = 1  # LH & HL

    return regimes

# Detect swing points
min_distance = 1
hsp_indices, lsp_indices = detect_swing_points(asi_values, min_distance=min_distance)

# Apply exceeding extremes filter
hsp_indices_filtered, lsp_indices_filtered = filter_by_exceeding_extremes(hsp_indices, lsp_indices, asi_values)

# Calculate regimes
regimes = calculate_asi_swing_pattern_regime_with_filtered_points(
    asi_values, hsp_indices_filtered, lsp_indices_filtered, lookback=200
)

# Create detailed DataFrame
analysis_df = pd.DataFrame({
    'Bar': range(len(asi_values)),
    'ASI': asi_values,
    'ASI_rounded': np.round(asi_values, 2),
    'is_HSP': [1 if i in hsp_indices_filtered else 0 for i in range(len(asi_values))],
    'is_LSP': [1 if i in lsp_indices_filtered else 0 for i in range(len(asi_values))]
})

# Add columns to track swing point history
analysis_df['prev_HSP_idx'] = np.nan
analysis_df['prev_HSP_val'] = np.nan
analysis_df['last_HSP_idx'] = np.nan
analysis_df['last_HSP_val'] = np.nan
analysis_df['prev_LSP_idx'] = np.nan
analysis_df['prev_LSP_val'] = np.nan
analysis_df['last_LSP_idx'] = np.nan
analysis_df['last_LSP_val'] = np.nan

# Add regime columns
analysis_df['HH'] = 0
analysis_df['LH'] = 0
analysis_df['HL'] = 0
analysis_df['LL'] = 0
analysis_df['Regime'] = ''

# Populate swing point history and regime information
for i in range(len(analysis_df)):
    # Find the most recent 2 swing highs and lows before position i
    recent_highs = [idx for idx in hsp_indices_filtered if idx <= i][-2:]
    recent_lows = [idx for idx in lsp_indices_filtered if idx <= i][-2:]

    # Populate swing point tracking columns
    if len(recent_highs) >= 2:
        analysis_df.loc[i, 'prev_HSP_idx'] = recent_highs[-2]
        analysis_df.loc[i, 'prev_HSP_val'] = asi_values[recent_highs[-2]]
        analysis_df.loc[i, 'last_HSP_idx'] = recent_highs[-1]
        analysis_df.loc[i, 'last_HSP_val'] = asi_values[recent_highs[-1]]

    if len(recent_lows) >= 2:
        analysis_df.loc[i, 'prev_LSP_idx'] = recent_lows[-2]
        analysis_df.loc[i, 'prev_LSP_val'] = asi_values[recent_lows[-2]]
        analysis_df.loc[i, 'last_LSP_idx'] = recent_lows[-1]
        analysis_df.loc[i, 'last_LSP_val'] = asi_values[recent_lows[-1]]

    # Determine patterns - only when we have 2 highs and 2 lows
    if len(recent_highs) >= 2 and len(recent_lows) >= 2:
        # Get values
        recent_high = asi_values[recent_highs[-1]]
        prev_high = asi_values[recent_highs[-2]]
        recent_low = asi_values[recent_lows[-1]]
        prev_low = asi_values[recent_lows[-2]]

        # Determine if we have higher highs or lower highs
        if recent_high > prev_high:
            analysis_df.loc[i, 'HH'] = 1
        else:
            analysis_df.loc[i, 'LH'] = 1

        # Determine if we have higher lows or lower lows
        if recent_low > prev_low:
            analysis_df.loc[i, 'HL'] = 1
        else:
            analysis_df.loc[i, 'LL'] = 1

        # Classify regime based on the combination
        if analysis_df.loc[i, 'HH'] == 1 and analysis_df.loc[i, 'HL'] == 1:
            analysis_df.loc[i, 'Regime'] = 'Uptrend'
        elif analysis_df.loc[i, 'LH'] == 1 and analysis_df.loc[i, 'LL'] == 1:
            analysis_df.loc[i, 'Regime'] = 'Downtrend'
        elif analysis_df.loc[i, 'HH'] == 1 and analysis_df.loc[i, 'LL'] == 1:
            analysis_df.loc[i, 'Regime'] = 'Bull_Div'
        elif analysis_df.loc[i, 'LH'] == 1 and analysis_df.loc[i, 'HL'] == 1:
            analysis_df.loc[i, 'Regime'] = 'Bear_Div'

# Display summary
print("\nRegime Summary:")
print(analysis_df['Regime'].value_counts())
print(f"\nTotal HSP: {analysis_df['is_HSP'].sum()}")
print(f"Total LSP: {analysis_df['is_LSP'].sum()}")

# Verify mutual exclusivity
hh_lh_conflicts = ((analysis_df['HH'] == 1) & (analysis_df['LH'] == 1)).sum()
hl_ll_conflicts = ((analysis_df['HL'] == 1) & (analysis_df['LL'] == 1)).sum()
print(f"\nMutual Exclusivity Check:")
print(f"HH & LH conflicts: {hh_lh_conflicts} (should be 0)")
print(f"HL & LL conflicts: {hl_ll_conflicts} (should be 0)")

# Show sample of the data with swing point tracking
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
analysis_df.head(30)

# Create interactive plot with slider for minimum swing distance
from ipywidgets import interact, IntSlider, Checkbox
import matplotlib.pyplot as plt
from IPython.display import display

def plot_price_with_asi_interactive(min_distance=10, require_exceeding=True):
    """Create price chart with ASI overlay and regime indicators"""

    # Detect swing points with specified minimum distance
    hsp_indices, lsp_indices = detect_swing_points(asi_values, min_distance=min_distance)

    # Apply exceeding extremes filter if requested
    if require_exceeding and (hsp_indices or lsp_indices):
        hsp_indices_filtered, lsp_indices_filtered = filter_by_exceeding_extremes(hsp_indices, lsp_indices, asi_values)
    else:
        hsp_indices_filtered, lsp_indices_filtered = hsp_indices, lsp_indices

    # Create figure
    fig = plt.figure(figsize=(15, 10))
    ax1 = plt.subplot(1, 1, 1)
    ax1_asi = ax1.twinx()

    # Plot OHLC candlestick chart
    x = np.arange(len(df))

    for i in range(len(df)):
        color = 'g' if df['Close'].iloc[i] >= df['Open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [df['Low'].iloc[i], df['High'].iloc[i]], color=color, linewidth=1)
        rect = Rectangle((x[i]-0.3, min(df['Open'].iloc[i], df['Close'].iloc[i])),
                        0.6, abs(df['Close'].iloc[i] - df['Open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Create color array for ASI points
    asi_colors = ['orange'] * len(asi_values)
    for idx in hsp_indices_filtered:
        asi_colors[idx] = 'purple'
    for idx in lsp_indices_filtered:
        asi_colors[idx] = 'blue'

    # Plot ASI as colored dots
    ax1_asi.scatter(x, asi_values, c=asi_colors, s=5, alpha=0.7, zorder=10)

    # Calculate and plot regime indicators
    regimes = calculate_asi_swing_pattern_regime_with_filtered_points(
        asi_values, hsp_indices_filtered, lsp_indices_filtered, lookback=200
    )

    # Plot regime indicators as vertical bars
    regime_colors = {
        'swing_regime_uptrend': 'green',
        'swing_regime_downtrend': 'red',
        'swing_regime_bullish_divergence': 'orange',
        'swing_regime_bearish_divergence': 'purple'
    }

    regime_labels = {
        'swing_regime_uptrend': 'Strong Uptrend (HH & HL)',
        'swing_regime_downtrend': 'Strong Downtrend (LH & LL)',
        'swing_regime_bullish_divergence': 'Bullish Divergence (HH & LL)',
        'swing_regime_bearish_divergence': 'Bearish Divergence (LH & HL)'
    }

    # Position regime bars
    price_min = df['Low'].min()
    price_max = df['High'].max()
    price_range = price_max - price_min

    # Base position for regime indicators (below price chart)
    regime_base = price_min - price_range * 0.05
    regime_height = price_range * 0.03
    regime_spacing = price_range * 0.035

    # Draw regime bars as individual vertical lines
    regime_order = ['swing_regime_bearish_divergence', 'swing_regime_bullish_divergence',
                   'swing_regime_downtrend', 'swing_regime_uptrend']

    # Bar width (same as price bars)
    bar_width = 0.6

    for idx, regime_name in enumerate(regime_order):
        values = regimes[regime_name]
        y_position = regime_base - idx * regime_spacing

        # Draw individual vertical bars for each time step where regime is active
        for i in range(len(values)):
            if values[i] == 1:
                # Draw vertical bar
                rect = Rectangle((x[i] - bar_width/2, y_position - regime_height/2),
                               bar_width, regime_height,
                               facecolor=regime_colors[regime_name],
                               edgecolor='none',
                               alpha=0.8)
                ax1.add_patch(rect)

    # Add regime labels on the left
    for idx, regime_name in enumerate(regime_order):
        y_position = regime_base - idx * regime_spacing
        label_text = regime_labels[regime_name]
        ax1.text(-5, y_position, label_text, fontsize=8, va='center', ha='right',
                color=regime_colors[regime_name], weight='bold')

    # Add thin horizontal lines to separate regime rows
    for idx in range(len(regime_order) + 1):
        y_position = regime_base - (idx - 0.5) * regime_spacing
        ax1.axhline(y=y_position, color='gray', linewidth=0.5, alpha=0.3, linestyle='--')

    # Set labels and title
    filter_mode = " [Exceeding Extremes]" if require_exceeding else " [All Swing Points]"
    ax1.set_xlabel('Bar')
    ax1.set_ylabel('Price', color='black')
    ax1_asi.set_ylabel('ASI', color='black')
    ax1.set_title(f'OHLC Price Chart with ASI Overlay and Regime Indicators{filter_mode}\n' +
                  f'Min Distance: {min_distance} bars | HSP: {len(hsp_indices_filtered)} (Purple) | LSP: {len(lsp_indices_filtered)} (Blue)',
                  fontsize=14)

    # Add legend
    from matplotlib.lines import Line2D
    legend_elements = [
        Line2D([0], [0], marker='o', color='w', markerfacecolor='orange', markersize=6, label='ASI'),
        Line2D([0], [0], marker='o', color='w', markerfacecolor='purple', markersize=6, label='HSP'),
        Line2D([0], [0], marker='o', color='w', markerfacecolor='blue', markersize=6, label='LSP')
    ]
    ax1_asi.legend(handles=legend_elements, loc='upper left', fontsize=8)

    ax1.grid(True, alpha=0.3)

    # Adjust y-axis limits
    y_min = regime_base - (len(regime_order) - 1) * regime_spacing - regime_height
    ax1.set_ylim(y_min, price_max * 1.02)

    plt.tight_layout()
    plt.show()

    # Print swing point statistics
    print(f"\nSwing Point Statistics:")
    print(f"Total HSP: {len(hsp_indices_filtered)}")
    print(f"Total LSP: {len(lsp_indices_filtered)}")

    # Calculate regime distribution
    regime_counts = {}
    for regime_name in regime_order:
        count = int(regimes[regime_name].sum())
        if count > 0:
            regime_counts[regime_labels[regime_name]] = count

    if regime_counts:
        print(f"\nRegime Distribution:")
        for regime, count in regime_counts.items():
            percentage = (count / len(asi_values)) * 100
            print(f"{regime}: {count} bars ({percentage:.1f}%)")

    # Verify alternation
    all_swings = []
    for idx in hsp_indices_filtered:
        all_swings.append((idx, 'H'))
    for idx in lsp_indices_filtered:
        all_swings.append((idx, 'L'))
    all_swings.sort(key=lambda x: x[0])

    if len(all_swings) > 0:
        print(f"\nFirst 10 swing points:")
        for i, (idx, swing_type) in enumerate(all_swings[:10]):
            asi_val = asi_values[idx]
            print(f"Bar {idx}: {swing_type} (ASI: {asi_val:.2f})")

# Create interactive widget
interact(plot_price_with_asi_interactive,
         min_distance=IntSlider(min=1, max=30, step=1, value=1, description='Min Distance:'),
         require_exceeding=Checkbox(value=True, description='Require Exceeding Extremes'))

# Test different minimum distances
test_distances = [5, 10, 15, 20]

fig, axes = plt.subplots(2, 2, figsize=(15, 10))
axes = axes.ravel()

for i, min_dist in enumerate(test_distances):
    ax = axes[i]

    # Detect swing points
    hsp_idx, lsp_idx = detect_swing_points(asi_values, min_distance=min_dist)
    hsp_idx_filt, lsp_idx_filt = filter_by_exceeding_extremes(hsp_idx, lsp_idx, asi_values)

    # Plot
    ax.plot(asi_values, 'gray', alpha=0.5, linewidth=1)

    for idx in hsp_idx_filt:
        ax.plot(idx, asi_values[idx], 'ro', markersize=6)
    for idx in lsp_idx_filt:
        ax.plot(idx, asi_values[idx], 'go', markersize=6)

    ax.set_title(f'Min Distance: {min_dist} (HSP: {len(hsp_idx_filt)}, LSP: {len(lsp_idx_filt)})')
    ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print('----------------------------- df --------------------------------')
print(df.head())
print(df.tail())
print('----------------------------- analysis_df --------------------------------')
print(analysis_df.head())
print(analysis_df.tail())

# Additional ASI Analysis with Slopes and Acceleration
def calculate_additional_asi_analysis(analysis_df, df, asi_values, hsp_indices_filtered, lsp_indices_filtered, n_lags=10):
    """Calculate additional ASI metrics including slopes and acceleration"""

    # Create a copy of analysis_df to add new columns
    additional_asi_analysis = analysis_df.copy()

    # Initialize new columns
    additional_asi_analysis['asi_slope'] = np.nan
    additional_asi_analysis['asi_acceleration'] = np.nan
    additional_asi_analysis['slope_hsps'] = np.nan
    additional_asi_analysis['slope_lsps'] = np.nan

    # Calculate ASI slope (change in ASI over n_lags periods)
    for i in range(n_lags, len(additional_asi_analysis)):
        asi_current = additional_asi_analysis.loc[i, 'ASI']
        asi_prev = additional_asi_analysis.loc[i - n_lags, 'ASI']
        additional_asi_analysis.loc[i, 'asi_slope'] = (asi_current - asi_prev) / n_lags

    # Calculate ASI acceleration (change in ASI slope over n_lags periods)
    for i in range(2 * n_lags, len(additional_asi_analysis)):
        slope_current = additional_asi_analysis.loc[i, 'asi_slope']
        slope_prev = additional_asi_analysis.loc[i - n_lags, 'asi_slope']
        if not np.isnan(slope_current) and not np.isnan(slope_prev):
            additional_asi_analysis.loc[i, 'asi_acceleration'] = (slope_current - slope_prev) / n_lags

    # Calculate slope of HSPs and LSPs for each bar
    for i in range(len(additional_asi_analysis)):
        # Find the most recent 2 HSPs before or at position i
        recent_hsps = [idx for idx in hsp_indices_filtered if idx <= i][-2:]
        if len(recent_hsps) == 2:
            # Calculate slope between the two HSPs (ASI pips per bar)
            hsp1_idx, hsp2_idx = recent_hsps[0], recent_hsps[1]
            hsp1_val = asi_values[hsp1_idx]
            hsp2_val = asi_values[hsp2_idx]
            bars_between = hsp2_idx - hsp1_idx
            if bars_between > 0:
                additional_asi_analysis.loc[i, 'slope_hsps'] = (hsp2_val - hsp1_val) / bars_between

        # Find the most recent 2 LSPs before or at position i
        recent_lsps = [idx for idx in lsp_indices_filtered if idx <= i][-2:]
        if len(recent_lsps) == 2:
            # Calculate slope between the two LSPs (ASI pips per bar)
            lsp1_idx, lsp2_idx = recent_lsps[0], recent_lsps[1]
            lsp1_val = asi_values[lsp1_idx]
            lsp2_val = asi_values[lsp2_idx]
            bars_between = lsp2_idx - lsp1_idx
            if bars_between > 0:
                additional_asi_analysis.loc[i, 'slope_lsps'] = (lsp2_val - lsp1_val) / bars_between

    return additional_asi_analysis

# Create the additional analysis DataFrame
additional_asi_analysis = calculate_additional_asi_analysis(
    analysis_df, df, asi_values, hsp_indices_filtered, lsp_indices_filtered, n_lags=10
)

# Display sample of the new analysis
print("Additional ASI Analysis Sample:")
print("\nColumns:", list(additional_asi_analysis.columns))
print("\nSample data (rows 100-110):")
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
additional_asi_analysis[['Bar', 'ASI', 'asi_slope', 'asi_acceleration', 'slope_hsps', 'slope_lsps', 'Regime']][100:111]

# Visualize additional ASI analysis with price chart
def plot_asi_with_slopes(additional_asi_analysis, df, n_lags=10):
    """Plot price chart with ASI analysis including slopes and acceleration"""

    fig, axes = plt.subplots(4, 1, figsize=(15, 12), height_ratios=[3, 1, 1, 1])

    # 1. Price chart with ASI overlay
    ax1 = axes[0]
    ax1_asi = ax1.twinx()

    x = np.arange(len(df))

    # Plot OHLC
    for i in range(len(df)):
        color = 'g' if df['Close'].iloc[i] >= df['Open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [df['Low'].iloc[i], df['High'].iloc[i]], color=color, linewidth=1)
        rect = Rectangle((x[i]-0.3, min(df['Open'].iloc[i], df['Close'].iloc[i])),
                        0.6, abs(df['Close'].iloc[i] - df['Open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Plot ASI with swing point colors
    asi_colors = ['orange'] * len(additional_asi_analysis)
    for i in range(len(additional_asi_analysis)):
        if additional_asi_analysis.loc[i, 'is_HSP'] == 1:
            asi_colors[i] = 'purple'
        elif additional_asi_analysis.loc[i, 'is_LSP'] == 1:
            asi_colors[i] = 'blue'

    ax1_asi.scatter(x, additional_asi_analysis['ASI'], c=asi_colors, s=3, alpha=0.7)

    ax1.set_ylabel('Price', color='black')
    ax1_asi.set_ylabel('ASI', color='black')
    ax1.set_title(f'Price Chart with ASI Overlay (n_lags={n_lags})', fontsize=14)
    ax1.grid(True, alpha=0.3)

    # 2. ASI Slope
    ax2 = axes[1]
    ax2.plot(x, additional_asi_analysis['asi_slope'], 'b-', linewidth=1, label='ASI Slope')
    ax2.axhline(y=0, color='gray', linestyle='--', alpha=0.5)
    ax2.fill_between(x, 0, additional_asi_analysis['asi_slope'],
                     where=additional_asi_analysis['asi_slope'] > 0, alpha=0.3, color='green', label='Positive')
    ax2.fill_between(x, 0, additional_asi_analysis['asi_slope'],
                     where=additional_asi_analysis['asi_slope'] < 0, alpha=0.3, color='red', label='Negative')
    ax2.set_ylabel(f'ASI Slope\n(Δ per {n_lags} bars)')
    ax2.legend(loc='upper left', fontsize=8)
    ax2.grid(True, alpha=0.3)

    # 3. ASI Acceleration
    ax3 = axes[2]
    ax3.plot(x, additional_asi_analysis['asi_acceleration'], 'purple', linewidth=1, label='ASI Acceleration')
    ax3.axhline(y=0, color='gray', linestyle='--', alpha=0.5)
    ax3.fill_between(x, 0, additional_asi_analysis['asi_acceleration'],
                     where=additional_asi_analysis['asi_acceleration'] > 0, alpha=0.3, color='purple')
    ax3.fill_between(x, 0, additional_asi_analysis['asi_acceleration'],
                     where=additional_asi_analysis['asi_acceleration'] < 0, alpha=0.3, color='orange')
    ax3.set_ylabel(f'ASI Acceleration\n(Δ² per {n_lags}² bars)')
    ax3.legend(loc='upper left', fontsize=8)
    ax3.grid(True, alpha=0.3)

    # 4. Swing Point Slopes
    ax4 = axes[3]
    ax4.plot(x, additional_asi_analysis['slope_hsps'], 'purple', linewidth=1.5, label='HSP Slope', alpha=0.8)
    ax4.plot(x, additional_asi_analysis['slope_lsps'], 'blue', linewidth=1.5, label='LSP Slope', alpha=0.8)
    ax4.axhline(y=0, color='gray', linestyle='--', alpha=0.5)

    # Fill between HSP and LSP slopes
    ax4.fill_between(x, additional_asi_analysis['slope_hsps'], additional_asi_analysis['slope_lsps'],
                     where=additional_asi_analysis['slope_hsps'] > additional_asi_analysis['slope_lsps'],
                     alpha=0.2, color='green', label='HSP > LSP (Bullish)')
    ax4.fill_between(x, additional_asi_analysis['slope_hsps'], additional_asi_analysis['slope_lsps'],
                     where=additional_asi_analysis['slope_hsps'] < additional_asi_analysis['slope_lsps'],
                     alpha=0.2, color='red', label='HSP < LSP (Bearish)')

    ax4.set_ylabel('Swing Slopes\n(ASI/bar)')
    ax4.set_xlabel('Bar')
    ax4.legend(loc='upper left', fontsize=8)
    ax4.grid(True, alpha=0.3)

    # Add regime coloring to background of bottom plot
    regimes = additional_asi_analysis['Regime']
    regime_colors = {
        'Uptrend': 'green',
        'Downtrend': 'red',
        'Bull_Div': 'orange',
        'Bear_Div': 'purple'
    }

    for regime, color in regime_colors.items():
        mask = regimes == regime
        if mask.any():
            ax4.fill_between(x, ax4.get_ylim()[0], ax4.get_ylim()[1],
                           where=mask, alpha=0.1, color=color)

    plt.tight_layout()
    plt.show()

    # Print statistics
    print("\nAdditional ASI Analysis Statistics:")
    print(f"\nASI Slope (last 50 bars):")
    print(f"  Mean: {additional_asi_analysis['asi_slope'][-50:].mean():.4f}")
    print(f"  Std:  {additional_asi_analysis['asi_slope'][-50:].std():.4f}")

    print(f"\nASI Acceleration (last 50 bars):")
    print(f"  Mean: {additional_asi_analysis['asi_acceleration'][-50:].mean():.6f}")
    print(f"  Std:  {additional_asi_analysis['asi_acceleration'][-50:].std():.6f}")

    print(f"\nSwing Point Slopes (current):")
    current_hsp_slope = additional_asi_analysis['slope_hsps'].iloc[-1]
    current_lsp_slope = additional_asi_analysis['slope_lsps'].iloc[-1]
    if not np.isnan(current_hsp_slope):
        print(f"  HSP Slope: {current_hsp_slope:.4f} ASI/bar")
    if not np.isnan(current_lsp_slope):
        print(f"  LSP Slope: {current_lsp_slope:.4f} ASI/bar")

    if not np.isnan(current_hsp_slope) and not np.isnan(current_lsp_slope):
        divergence = current_hsp_slope - current_lsp_slope
        print(f"  Divergence (HSP-LSP): {divergence:.4f}")
        if divergence > 0:
            print("  → Bullish (HSP slope > LSP slope)")
        else:
            print("  → Bearish (HSP slope < LSP slope)")

# Plot the additional ASI analysis
plot_asi_with_slopes(additional_asi_analysis, df, n_lags=10)

# Parabolic SAR Implementation based on Welles Wilder's Original Work
def calculate_parabolic_sar(df, af_start=0.02, af_increment=0.02, af_max=0.20, pip_size=0.001):
    """
    Calculate Parabolic SAR (Stop and Reverse) based on Welles Wilder's method.

    Parameters:
    - df: DataFrame with OHLC data
    - af_start: Initial acceleration factor (default 0.02)
    - af_increment: AF increment for each new extreme (default 0.02)
    - af_max: Maximum acceleration factor (default 0.20)
    - pip_size: Size of one pip (default 0.0001 for most forex pairs)

    Returns:
    - Dictionary with SAR values, position (1=long, -1=short), and psar_delta in pips
    """
    n = len(df)

    # Initialize arrays
    sar = np.zeros(n)
    position = np.zeros(n)  # 1 for long, -1 for short
    af = np.zeros(n)
    ep = np.zeros(n)  # Extreme price

    # Start with a long position (can be changed based on initial trend)
    # Use first bar's low as initial SAR for long position
    sar[0] = df['Low'].iloc[0]
    position[0] = 1
    af[0] = af_start
    ep[0] = df['High'].iloc[0]

    for i in range(1, n):
        # Check if we need to reverse position
        if position[i-1] == 1:  # Currently long
            # Check if low penetrated SAR (reverse to short)
            if df['Low'].iloc[i] <= sar[i-1]:
                position[i] = -1  # Reverse to short
                sar[i] = ep[i-1]  # New SAR is previous extreme high
                ep[i] = df['Low'].iloc[i]  # New EP is current low
                af[i] = af_start  # Reset AF
            else:
                position[i] = 1  # Stay long
                # Update SAR using formula: SAR_tomorrow = SAR_today + AF(EP_trade - SAR_today)
                sar[i] = sar[i-1] + af[i-1] * (ep[i-1] - sar[i-1])

                # Make sure SAR doesn't go above previous or current low
                sar[i] = min(sar[i], df['Low'].iloc[i-1], df['Low'].iloc[i])

                # Update EP if new high is made
                if df['High'].iloc[i] > ep[i-1]:
                    ep[i] = df['High'].iloc[i]
                    af[i] = min(af[i-1] + af_increment, af_max)
                else:
                    ep[i] = ep[i-1]
                    af[i] = af[i-1]

        else:  # Currently short
            # Check if high penetrated SAR (reverse to long)
            if df['High'].iloc[i] >= sar[i-1]:
                position[i] = 1  # Reverse to long
                sar[i] = ep[i-1]  # New SAR is previous extreme low
                ep[i] = df['High'].iloc[i]  # New EP is current high
                af[i] = af_start  # Reset AF
            else:
                position[i] = -1  # Stay short
                # Update SAR using formula
                sar[i] = sar[i-1] + af[i-1] * (ep[i-1] - sar[i-1])

                # Make sure SAR doesn't go below previous or current high
                sar[i] = max(sar[i], df['High'].iloc[i-1], df['High'].iloc[i])

                # Update EP if new low is made
                if df['Low'].iloc[i] < ep[i-1]:
                    ep[i] = df['Low'].iloc[i]
                    af[i] = min(af[i-1] + af_increment, af_max)
                else:
                    ep[i] = ep[i-1]
                    af[i] = af[i-1]

    # Calculate psar_delta in PIPS (close - SAR, positive for long, negative for short)
    # Convert to pips by dividing by pip_size
    psar_delta = ((df['Close'].values - sar) * position) / pip_size

    return {
        'sar': sar,
        'position': position,
        'af': af,
        'ep': ep,
        'psar_delta': psar_delta
    }

# Calculate Parabolic SAR with standard parameters
# For most forex pairs: 1 pip = 0.0001 (e.g., EUR/USD 1.1234 to 1.1235 = 1 pip)
# For JPY pairs: 1 pip = 0.01 (e.g., USD/JPY 110.12 to 110.13 = 1 pip)
pip_size = 0.001  # Standard for non-JPY pairs
psar_data = calculate_parabolic_sar(df, pip_size=pip_size)

# Add to additional_asi_analysis DataFrame
additional_asi_analysis['psar'] = psar_data['sar']
additional_asi_analysis['psar_position'] = psar_data['position']
additional_asi_analysis['psar_delta'] = psar_data['psar_delta']

# Display sample
print("Parabolic SAR Analysis Sample (last 20 bars):")
print("\nColumns explanation:")
print("- psar: The SAR value (stop level)")
print("- psar_position: 1 for long, -1 for short")
print("- psar_delta: Close - SAR in PIPS, adjusted for position direction")
print(f"\nPip size = {pip_size} (1 pip = {pip_size} price units)")
print(f"Example: Price 0.9800 to 0.9810 = {0.0010/pip_size:.0f} pips")
print("\nData:")
pd.set_option('display.max_columns', None)
additional_asi_analysis[['Bar', 'ASI', 'psar', 'psar_position', 'psar_delta', 'Regime']][-20:]

# Visualize Parabolic SAR with Price Chart and PSAR Delta
def plot_parabolic_sar_analysis(df, additional_asi_analysis):
    """Plot price chart with Parabolic SAR indicator and PSAR delta subplot"""

    fig, axes = plt.subplots(2, 1, figsize=(15, 10), height_ratios=[3, 1])

    # 1. Price chart with Parabolic SAR
    ax1 = axes[0]
    x = np.arange(len(df))

    # Plot OHLC candlesticks
    for i in range(len(df)):
        color = 'g' if df['Close'].iloc[i] >= df['Open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [df['Low'].iloc[i], df['High'].iloc[i]], color=color, linewidth=1)
        rect = Rectangle((x[i]-0.3, min(df['Open'].iloc[i], df['Close'].iloc[i])),
                        0.6, abs(df['Close'].iloc[i] - df['Open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Plot Parabolic SAR
    psar = additional_asi_analysis['psar'].values
    psar_position = additional_asi_analysis['psar_position'].values

    # Plot SAR dots below price for long positions (green) and above for short positions (red)
    long_mask = psar_position == 1
    short_mask = psar_position == -1

    ax1.scatter(x[long_mask], psar[long_mask], color='green', s=20, label='SAR (Long)', zorder=5)
    ax1.scatter(x[short_mask], psar[short_mask], color='red', s=20, label='SAR (Short)', zorder=5)

    # Draw position changes with vertical lines
    position_changes = np.where(np.diff(psar_position) != 0)[0] + 1
    for change_idx in position_changes:
        if change_idx < len(x):
            ax1.axvline(x=x[change_idx], color='gray', alpha=0.3, linestyle='--', linewidth=0.5)

    ax1.set_ylabel('Price', fontsize=12)
    ax1.set_title('Price Chart with Parabolic SAR Indicator', fontsize=14)
    ax1.legend(loc='upper left')
    ax1.grid(True, alpha=0.3)

    # 2. PSAR Delta subplot
    ax2 = axes[1]
    psar_delta = additional_asi_analysis['psar_delta'].values

    # Plot PSAR delta as bars
    colors = ['green' if val > 0 else 'red' for val in psar_delta]
    ax2.bar(x, psar_delta, color=colors, alpha=0.7, width=0.8)

    # Add zero line
    ax2.axhline(y=0, color='black', linestyle='-', linewidth=0.5)

    # Highlight position changes
    for change_idx in position_changes:
        if change_idx < len(x):
            ax2.axvline(x=x[change_idx], color='gray', alpha=0.3, linestyle='--', linewidth=0.5)

    ax2.set_ylabel('PSAR Delta (pips)', fontsize=12)
    ax2.set_xlabel('Bar', fontsize=12)
    ax2.set_title('Parabolic SAR Delta (Close - SAR, positive for long, negative for short)', fontsize=12)
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

    # Print statistics
    print("\nParabolic SAR Statistics:")
    print(f"Total position changes: {len(position_changes)}")
    print(f"Average bars per position: {len(df) / (len(position_changes) + 1):.1f}")

    # Calculate performance by position
    long_delta = psar_delta[long_mask]
    short_delta = psar_delta[short_mask]

    if len(long_delta) > 0:
        print(f"\nLong positions:")
        print(f"  Bars: {len(long_delta)} ({len(long_delta)/len(df)*100:.1f}%)")
        print(f"  Avg PSAR Delta: {np.mean(long_delta):.4f}")
        print(f"  Total PSAR Delta: {np.sum(long_delta):.2f}")

    if len(short_delta) > 0:
        print(f"\nShort positions:")
        print(f"  Bars: {len(short_delta)} ({len(short_delta)/len(df)*100:.1f}%)")
        print(f"  Avg PSAR Delta: {np.mean(short_delta):.4f}")
        print(f"  Total PSAR Delta: {np.sum(short_delta):.2f}")

    print(f"\nOverall performance:")
    print(f"  Total PSAR Delta: {np.sum(psar_delta):.2f}")

# Plot the Parabolic SAR analysis
plot_parabolic_sar_analysis(df, additional_asi_analysis)

# Comprehensive Visualization - All Indicators Combined
def plot_comprehensive_analysis(df, additional_asi_analysis, asi_values, hsp_indices_filtered, lsp_indices_filtered):
    """Create comprehensive plot with all indicators: Price, ASI, Swing Points, Regimes, and Parabolic SAR"""

    fig, axes = plt.subplots(3, 1, figsize=(16, 14), height_ratios=[3, 1, 1])

    # 1. Main Price Chart with Multiple Overlays
    ax1 = axes[0]
    ax1_asi = ax1.twinx()

    x = np.arange(len(df))

    # Plot OHLC candlesticks
    for i in range(len(df)):
        color = 'g' if df['Close'].iloc[i] >= df['Open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [df['Low'].iloc[i], df['High'].iloc[i]], color=color, linewidth=1)
        rect = Rectangle((x[i]-0.3, min(df['Open'].iloc[i], df['Close'].iloc[i])),
                        0.6, abs(df['Close'].iloc[i] - df['Open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Plot ASI with swing point colors
    asi_colors = ['orange'] * len(asi_values)
    for idx in hsp_indices_filtered:
        asi_colors[idx] = 'purple'
    for idx in lsp_indices_filtered:
        asi_colors[idx] = 'blue'

    ax1_asi.scatter(x, asi_values, c=asi_colors, s=3, alpha=0.7, zorder=5)

    # Plot Parabolic SAR
    psar = additional_asi_analysis['psar'].values
    psar_position = additional_asi_analysis['psar_position'].values

    # Plot SAR dots
    long_mask = psar_position == 1
    short_mask = psar_position == -1

    ax1.scatter(x[long_mask], psar[long_mask], color='green', s=15, marker='o',
                label='SAR (Long)', zorder=10, edgecolors='darkgreen', linewidth=0.5)
    ax1.scatter(x[short_mask], psar[short_mask], color='red', s=15, marker='o',
                label='SAR (Short)', zorder=10, edgecolors='darkred', linewidth=0.5)

    # Add regime indicators at bottom
    regimes = additional_asi_analysis['Regime']
    regime_colors = {
        'Uptrend': 'green',
        'Downtrend': 'red',
        'Bull_Div': 'orange',
        'Bear_Div': 'purple'
    }

    # Position regime bars
    price_min = df['Low'].min()
    price_max = df['High'].max()
    price_range = price_max - price_min

    regime_base = price_min - price_range * 0.05
    regime_height = price_range * 0.025
    regime_spacing = price_range * 0.03

    # Draw regime bars as individual vertical lines
    regime_order = ['Bear_Div', 'Bull_Div', 'Downtrend', 'Uptrend']
    bar_width = 0.6

    for idx, regime_name in enumerate(regime_order):
        y_position = regime_base - idx * regime_spacing

        # Find where this regime is active
        regime_mask = regimes == regime_name
        active_bars = x[regime_mask]

        # Draw individual bars
        for bar_x in active_bars:
            rect = Rectangle((bar_x - bar_width/2, y_position - regime_height/2),
                           bar_width, regime_height,
                           facecolor=regime_colors[regime_name],
                           edgecolor='none',
                           alpha=0.8)
            ax1.add_patch(rect)

    # Add regime labels
    regime_full_names = {
        'Uptrend': 'Strong Uptrend (HH & HL)',
        'Downtrend': 'Strong Downtrend (LH & LL)',
        'Bull_Div': 'Bullish Divergence (HH & LL)',
        'Bear_Div': 'Bearish Divergence (LH & HL)'
    }

    for idx, regime_name in enumerate(regime_order):
        y_position = regime_base - idx * regime_spacing
        label_text = regime_full_names[regime_name]
        ax1.text(-5, y_position, label_text, fontsize=8, va='center', ha='right',
                color=regime_colors[regime_name], weight='bold')

    # Set labels and title
    ax1.set_ylabel('Price', fontsize=12)
    ax1_asi.set_ylabel('ASI', fontsize=12, color='darkorange')
    ax1_asi.tick_params(axis='y', labelcolor='darkorange')
    ax1.set_title('Comprehensive Analysis: Price, ASI, Swing Points, Regimes & Parabolic SAR', fontsize=14)

    # Add legends
    from matplotlib.lines import Line2D
    # Price legend
    price_legend = ax1.legend(loc='upper left', fontsize=8)

    # ASI legend (custom)
    asi_legend_elements = [
        Line2D([0], [0], marker='o', color='w', markerfacecolor='orange', markersize=6, label='ASI'),
        Line2D([0], [0], marker='o', color='w', markerfacecolor='purple', markersize=6, label='HSP'),
        Line2D([0], [0], marker='o', color='w', markerfacecolor='blue', markersize=6, label='LSP')
    ]
    asi_legend = ax1_asi.legend(handles=asi_legend_elements, loc='upper right', fontsize=8)

    ax1.grid(True, alpha=0.3)

    # Adjust y-axis to show regime indicators
    y_min = regime_base - (len(regime_order) - 1) * regime_spacing - regime_height
    ax1.set_ylim(y_min, price_max * 1.02)

    # 2. PSAR Delta subplot
    ax2 = axes[1]
    psar_delta = additional_asi_analysis['psar_delta'].values

    # Plot PSAR delta as bars
    colors = ['green' if val > 0 else 'red' for val in psar_delta]
    ax2.bar(x, psar_delta, color=colors, alpha=0.7, width=0.8)

    # Add zero line
    ax2.axhline(y=0, color='black', linestyle='-', linewidth=0.5)

    # Highlight position changes
    position_changes = np.where(np.diff(psar_position) != 0)[0] + 1
    for change_idx in position_changes:
        if change_idx < len(x):
            ax2.axvline(x=x[change_idx], color='gray', alpha=0.3, linestyle='--', linewidth=0.5)

    ax2.set_ylabel('PSAR Delta (pips)', fontsize=10)
    ax2.set_title('Parabolic SAR Delta (distance from stop in pips)', fontsize=10)
    ax2.grid(True, alpha=0.3)

    # 3. ASI Slope and Swing Point Slopes
    ax3 = axes[2]

    # Plot ASI slope
    asi_slope = additional_asi_analysis['asi_slope'].values
    ax3.plot(x, asi_slope, 'darkblue', linewidth=1, alpha=0.7, label='ASI Slope')
    ax3.fill_between(x, 0, asi_slope, where=asi_slope > 0, alpha=0.2, color='green')
    ax3.fill_between(x, 0, asi_slope, where=asi_slope < 0, alpha=0.2, color='red')

    # Plot swing point slopes on secondary y-axis
    ax3_swings = ax3.twinx()
    slope_hsps = additional_asi_analysis['slope_hsps'].values
    slope_lsps = additional_asi_analysis['slope_lsps'].values

    ax3_swings.plot(x, slope_hsps, 'purple', linewidth=1.5, label='HSP Slope', alpha=0.8)
    ax3_swings.plot(x, slope_lsps, 'blue', linewidth=1.5, label='LSP Slope', alpha=0.8)

    # Zero lines
    ax3.axhline(y=0, color='gray', linestyle='-', alpha=0.5, linewidth=0.5)

    ax3.set_ylabel('ASI Slope', fontsize=10, color='darkblue')
    ax3.tick_params(axis='y', labelcolor='darkblue')
    ax3_swings.set_ylabel('Swing Slopes', fontsize=10, color='purple')
    ax3_swings.tick_params(axis='y', labelcolor='purple')
    ax3.set_xlabel('Bar', fontsize=10)
    ax3.set_title('ASI Momentum Analysis', fontsize=10)

    ax3.legend(loc='upper left', fontsize=8)
    ax3_swings.legend(loc='upper right', fontsize=8)
    ax3.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

    # Print comprehensive statistics
    print("\n" + "="*60)
    print("COMPREHENSIVE ANALYSIS SUMMARY")
    print("="*60)

    print(f"\nData Range: {len(df)} bars")
    print(f"Price Range: {df['Low'].min():.5f} to {df['High'].max():.5f}")

    print(f"\nSwing Points:")
    print(f"  High Swing Points (HSP): {len(hsp_indices_filtered)}")
    print(f"  Low Swing Points (LSP): {len(lsp_indices_filtered)}")

    print(f"\nRegime Distribution:")
    regime_counts = regimes.value_counts()
    for regime, count in regime_counts.items():
        if regime:  # Skip empty
            percentage = (count / len(df)) * 100
            print(f"  {regime_full_names.get(regime, regime)}: {count} bars ({percentage:.1f}%)")

    print(f"\nParabolic SAR:")
    print(f"  Position Changes: {len(position_changes)}")
    print(f"  Current Position: {'Long' if psar_position[-1] == 1 else 'Short'}")
    print(f"  Current PSAR Delta: {psar_delta[-1]:.2f} pips")

    # Current momentum
    if not np.isnan(additional_asi_analysis['asi_slope'].iloc[-1]):
        print(f"\nCurrent Momentum:")
        print(f"  ASI Slope: {additional_asi_analysis['asi_slope'].iloc[-1]:.4f}")
        if not np.isnan(additional_asi_analysis['slope_hsps'].iloc[-1]):
            print(f"  HSP Slope: {additional_asi_analysis['slope_hsps'].iloc[-1]:.4f}")
        if not np.isnan(additional_asi_analysis['slope_lsps'].iloc[-1]):
            print(f"  LSP Slope: {additional_asi_analysis['slope_lsps'].iloc[-1]:.4f}")

# Create the comprehensive visualization
plot_comprehensive_analysis(df, additional_asi_analysis, asi_values, hsp_indices_filtered, lsp_indices_filtered)

# RSI Implementation - Standard (Price-based) and ASI-based
def calculate_rsi(values, period=14):
    """
    Calculate RSI according to Wilder's method.

    Parameters:
    - values: Series of values (prices or ASI)
    - period: RSI period (default 14)

    Returns:
    - RSI values as numpy array
    """
    # Calculate price changes
    deltas = np.diff(values)

    # Separate gains and losses
    gains = np.where(deltas > 0, deltas, 0)
    losses = np.where(deltas < 0, -deltas, 0)

    # Initialize RSI array with NaN
    rsi = np.full(len(values), np.nan)

    # Calculate initial averages (Wilder's method)
    if len(gains) >= period:
        avg_gain = np.mean(gains[:period])
        avg_loss = np.mean(losses[:period])

        # Calculate first RSI value
        if avg_loss != 0:
            rs = avg_gain / avg_loss
            rsi[period] = 100 - (100 / (1 + rs))
        else:
            rsi[period] = 100

        # Calculate subsequent RSI values using Wilder's smoothing
        for i in range(period + 1, len(values)):
            avg_gain = (avg_gain * (period - 1) + gains[i-1]) / period
            avg_loss = (avg_loss * (period - 1) + losses[i-1]) / period

            if avg_loss != 0:
                rs = avg_gain / avg_loss
                rsi[i] = 100 - (100 / (1 + rs))
            else:
                rsi[i] = 100

    return rsi

# Calculate both RSI types
price_rsi = calculate_rsi(df['Close'].values, period=14)
asi_rsi = calculate_rsi(asi_values, period=14)

# Add to dataframe
additional_asi_analysis['price_rsi'] = price_rsi
additional_asi_analysis['asi_rsi'] = asi_rsi

# Plotting function
def plot_rsi_comparison(df, additional_asi_analysis, asi_values):
    """Plot price chart with both RSI indicators"""

    fig, axes = plt.subplots(3, 1, figsize=(16, 12), height_ratios=[2, 1, 1])

    # 1. Price Chart
    ax1 = axes[0]
    x = np.arange(len(df))

    # Plot OHLC candlesticks
    for i in range(len(df)):
        color = 'g' if df['Close'].iloc[i] >= df['Open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [df['Low'].iloc[i], df['High'].iloc[i]], color=color, linewidth=1)
        rect = Rectangle((x[i]-0.3, min(df['Open'].iloc[i], df['Close'].iloc[i])),
                        0.6, abs(df['Close'].iloc[i] - df['Open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Add ASI on secondary axis
    ax1_asi = ax1.twinx()
    ax1_asi.plot(x, asi_values, 'orange', linewidth=1, alpha=0.7, label='ASI')

    ax1.set_ylabel('Price', fontsize=12)
    ax1_asi.set_ylabel('ASI', fontsize=12, color='orange')
    ax1_asi.tick_params(axis='y', labelcolor='orange')
    ax1.set_title('Price Chart with ASI Overlay', fontsize=14)
    ax1.grid(True, alpha=0.3)
    ax1_asi.legend(loc='upper left')

    # 2. Price-based RSI
    ax2 = axes[1]
    ax2.plot(x, additional_asi_analysis['price_rsi'], 'blue', linewidth=1.5, label='Price RSI (14)')

    # Add overbought/oversold levels
    ax2.axhline(y=70, color='red', linestyle='--', alpha=0.5, label='Overbought (70)')
    ax2.axhline(y=30, color='green', linestyle='--', alpha=0.5, label='Oversold (30)')
    ax2.axhline(y=50, color='gray', linestyle='-', alpha=0.3)

    # Fill overbought/oversold regions
    ax2.fill_between(x, 70, 100, alpha=0.1, color='red')
    ax2.fill_between(x, 0, 30, alpha=0.1, color='green')

    ax2.set_ylabel('Price RSI', fontsize=12)
    ax2.set_ylim(0, 100)
    ax2.legend(loc='upper left', fontsize=9)
    ax2.grid(True, alpha=0.3)
    ax2.set_title('RSI based on Price (Standard Calculation)', fontsize=12)

    # 3. ASI-based RSI
    ax3 = axes[2]
    ax3.plot(x, additional_asi_analysis['asi_rsi'], 'purple', linewidth=1.5, label='ASI RSI (14)')

    # Add overbought/oversold levels
    ax3.axhline(y=70, color='red', linestyle='--', alpha=0.5, label='Overbought (70)')
    ax3.axhline(y=30, color='green', linestyle='--', alpha=0.5, label='Oversold (30)')
    ax3.axhline(y=50, color='gray', linestyle='-', alpha=0.3)

    # Fill overbought/oversold regions
    ax3.fill_between(x, 70, 100, alpha=0.1, color='red')
    ax3.fill_between(x, 0, 30, alpha=0.1, color='green')

    ax3.set_ylabel('ASI RSI', fontsize=12)
    ax3.set_xlabel('Bar', fontsize=12)
    ax3.set_ylim(0, 100)
    ax3.legend(loc='upper left', fontsize=9)
    ax3.grid(True, alpha=0.3)
    ax3.set_title('RSI based on ASI Changes', fontsize=12)

    plt.tight_layout()
    plt.show()

    # Print statistics
    print("\nRSI Analysis Summary:")
    print("="*50)

    # Price RSI stats
    price_rsi_clean = additional_asi_analysis['price_rsi'].dropna()
    if len(price_rsi_clean) > 0:
        print("\nPrice-based RSI Statistics:")
        print(f"  Current Value: {price_rsi_clean.iloc[-1]:.2f}")
        print(f"  Average: {price_rsi_clean.mean():.2f}")
        print(f"  Min: {price_rsi_clean.min():.2f}")
        print(f"  Max: {price_rsi_clean.max():.2f}")

        # Count overbought/oversold periods
        overbought = (price_rsi_clean > 70).sum()
        oversold = (price_rsi_clean < 30).sum()
        print(f"  Overbought periods (>70): {overbought} ({overbought/len(price_rsi_clean)*100:.1f}%)")
        print(f"  Oversold periods (<30): {oversold} ({oversold/len(price_rsi_clean)*100:.1f}%)")

    # ASI RSI stats
    asi_rsi_clean = additional_asi_analysis['asi_rsi'].dropna()
    if len(asi_rsi_clean) > 0:
        print("\nASI-based RSI Statistics:")
        print(f"  Current Value: {asi_rsi_clean.iloc[-1]:.2f}")
        print(f"  Average: {asi_rsi_clean.mean():.2f}")
        print(f"  Min: {asi_rsi_clean.min():.2f}")
        print(f"  Max: {asi_rsi_clean.max():.2f}")

        # Count overbought/oversold periods
        overbought = (asi_rsi_clean > 70).sum()
        oversold = (asi_rsi_clean < 30).sum()
        print(f"  Overbought periods (>70): {overbought} ({overbought/len(asi_rsi_clean)*100:.1f}%)")
        print(f"  Oversold periods (<30): {oversold} ({oversold/len(asi_rsi_clean)*100:.1f}%)")

    # Correlation between RSIs
    if len(price_rsi_clean) > 0 and len(asi_rsi_clean) > 0:
        # Align the series
        aligned_price = additional_asi_analysis['price_rsi'].dropna()
        aligned_asi = additional_asi_analysis['asi_rsi'].dropna()

        # Find common indices
        common_idx = aligned_price.index.intersection(aligned_asi.index)
        if len(common_idx) > 0:
            correlation = aligned_price[common_idx].corr(aligned_asi[common_idx])
            print(f"\nCorrelation between Price RSI and ASI RSI: {correlation:.3f}")

    # Divergence analysis
    print("\nDivergence Analysis (last 50 bars):")
    if len(price_rsi_clean) > 50 and len(asi_rsi_clean) > 50:
        recent_price_rsi = price_rsi_clean[-50:]
        recent_asi_rsi = asi_rsi_clean[-50:]

        # Check if RSIs are moving in opposite directions
        price_rsi_trend = np.polyfit(range(len(recent_price_rsi)), recent_price_rsi, 1)[0]
        asi_rsi_trend = np.polyfit(range(len(recent_asi_rsi)), recent_asi_rsi, 1)[0]

        print(f"  Price RSI trend: {'Upward' if price_rsi_trend > 0 else 'Downward'} ({price_rsi_trend:.3f})")
        print(f"  ASI RSI trend: {'Upward' if asi_rsi_trend > 0 else 'Downward'} ({asi_rsi_trend:.3f})")

        if np.sign(price_rsi_trend) != np.sign(asi_rsi_trend):
            print("  ⚠️ DIVERGENCE DETECTED: RSIs moving in opposite directions")

# Create the RSI comparison plot
plot_rsi_comparison(df, additional_asi_analysis, asi_values)

# Volatility Index (VI) Implementation - Welles Wilder's Original Method
def calculate_volatility_index(df, period=14):
    """
    Calculate Volatility Index (VI) according to Welles Wilder's method.
    VI uses Average True Range (ATR) over specified period.

    Parameters:
    - df: DataFrame with OHLC data
    - period: Period for ATR calculation (default 14 as per Wilder)

    Returns:
    - Dictionary with TR, ATR, and VI values
    """
    n = len(df)

    # Calculate True Range (TR)
    true_range = np.zeros(n)

    # First bar has no previous close, so TR = High - Low
    true_range[0] = df['High'].iloc[0] - df['Low'].iloc[0]

    # For subsequent bars, TR is max of three values
    for i in range(1, n):
        high_low = df['High'].iloc[i] - df['Low'].iloc[i]
        high_close = abs(df['High'].iloc[i] - df['Close'].iloc[i-1])
        low_close = abs(df['Low'].iloc[i] - df['Close'].iloc[i-1])

        true_range[i] = max(high_low, high_close, low_close)

    # Calculate ATR using Wilder's smoothing method
    atr = np.zeros(n)

    # Initial ATR is simple average of first 'period' TR values
    if n >= period:
        atr[period-1] = np.mean(true_range[:period])

        # Subsequent ATR values use Wilder's smoothing
        # ATR_today = (ATR_previous * (period-1) + TR_today) / period
        for i in range(period, n):
            atr[i] = (atr[i-1] * (period - 1) + true_range[i]) / period

    # The Volatility Index (VI) is essentially the ATR
    # According to Wilder: VI_today = (13 * VI_previous + TR_1) / 14
    # This is the same formula as ATR
    vi = atr.copy()

    return {
        'true_range': true_range,
        'atr': atr,
        'vi': vi
    }

# Calculate Volatility Index
vi_data = calculate_volatility_index(df, period=14)

# Create VI DataFrame
vi_df = pd.DataFrame({
    'date': df.index,
    'open': df['Open'],
    'high': df['High'],
    'low': df['Low'],
    'close': df['Close'],
    'true_range': vi_data['true_range'],
    'atr_14': vi_data['atr'],
    'vi': vi_data['vi']
})

# Display sample
print("Volatility Index (VI) Analysis Sample:")
print("\nFirst 20 rows:")
print(vi_df.head(20))
print("\nLast 10 rows:")
print(vi_df.tail(10))

# Volatility System Implementation - Welles Wilder's Trading System
def calculate_volatility_system(vi_df, arc_constant=3.0):
    """
    Implement Wilder's Volatility System using the Volatility Index.

    The system uses:
    - ARC (Average Range times Constant) = ATR × constant
    - SAR (Stop and Reverse) points
    - Position tracking (1 = Long, -1 = Short)

    Parameters:
    - vi_df: DataFrame with VI/ATR data
    - arc_constant: Multiplier for ATR (default 3.0)

    Returns:
    - DataFrame with system signals and positions
    """
    n = len(vi_df)

    # Initialize arrays
    position = np.zeros(n)  # 1 for long, -1 for short
    sic = np.zeros(n)  # Significant Close
    sar = np.zeros(n)  # Stop and Reverse
    arc = vi_df['atr_14'].values * arc_constant  # Average Range times Constant

    # Skip initial period where ATR is not yet calculated
    start_idx = 14  # First valid ATR is at index 13 (14th bar)

    # Initialize with a long position (can be changed based on initial trend)
    position[start_idx] = 1
    sic[start_idx] = vi_df['close'].iloc[start_idx]
    sar[start_idx] = sic[start_idx] - arc[start_idx]

    # Track entry/exit points for visualization
    entry_points = []
    exit_points = []

    for i in range(start_idx + 1, n):
        close = vi_df['close'].iloc[i]

        if position[i-1] == 1:  # Currently long
            # Update SIC if new high close
            sic[i] = max(sic[i-1], close)

            # Check if stopped out (close below SAR)
            if close <= sar[i-1]:
                # Reverse to short
                position[i] = -1
                sic[i] = close  # Reset SIC to current close
                sar[i] = sic[i] + arc[i]  # New SAR above for short
                exit_points.append((i, close, 'StopLong'))
                entry_points.append((i, close, 'GoShort'))
            else:
                # Stay long
                position[i] = 1
                sar[i] = sic[i] - arc[i]  # Update SAR

        else:  # Currently short (position == -1)
            # Update SIC if new low close
            sic[i] = min(sic[i-1], close)

            # Check if stopped out (close above SAR)
            if close >= sar[i-1]:
                # Reverse to long
                position[i] = 1
                sic[i] = close  # Reset SIC to current close
                sar[i] = sic[i] - arc[i]  # New SAR below for long
                exit_points.append((i, close, 'StopShort'))
                entry_points.append((i, close, 'GoLong'))
            else:
                # Stay short
                position[i] = -1
                sar[i] = sic[i] + arc[i]  # Update SAR

    # Add system data to dataframe
    vi_df['position'] = position
    vi_df['sic'] = sic
    vi_df['sar'] = sar
    vi_df['arc'] = arc

    return vi_df, entry_points, exit_points

# Calculate Volatility System signals
vi_df, entry_points, exit_points = calculate_volatility_system(vi_df, arc_constant=3.0)

# Calculate performance metrics
def calculate_system_performance(vi_df):
    """Calculate performance metrics for the Volatility System"""
    # Find position changes
    position_changes = vi_df['position'].diff() != 0
    trade_indices = vi_df.index[position_changes].tolist()

    trades = []
    for i in range(1, len(trade_indices)):
        entry_idx = trade_indices[i-1]
        exit_idx = trade_indices[i]

        entry_price = vi_df.loc[entry_idx, 'close']
        exit_price = vi_df.loc[exit_idx, 'close']
        position = vi_df.loc[entry_idx, 'position']

        if position == 1:  # Long trade
            profit = exit_price - entry_price
            profit_pct = (exit_price / entry_price - 1) * 100
        else:  # Short trade
            profit = entry_price - exit_price
            profit_pct = (entry_price / exit_price - 1) * 100

        trades.append({
            'entry_date': vi_df.loc[entry_idx, 'date'],
            'exit_date': vi_df.loc[exit_idx, 'date'],
            'position': 'Long' if position == 1 else 'Short',
            'entry_price': entry_price,
            'exit_price': exit_price,
            'profit': profit,
            'profit_pct': profit_pct,
            'bars_held': exit_idx - entry_idx
        })

    return pd.DataFrame(trades)

# Calculate performance
trades_df = calculate_system_performance(vi_df)

# Display system statistics
print("\nVolatility System Statistics:")
print(f"Total trades: {len(trades_df)}")
if len(trades_df) > 0:
    winning_trades = trades_df[trades_df['profit'] > 0]
    losing_trades = trades_df[trades_df['profit'] < 0]

    print(f"Winning trades: {len(winning_trades)} ({len(winning_trades)/len(trades_df)*100:.1f}%)")
    print(f"Losing trades: {len(losing_trades)} ({len(losing_trades)/len(trades_df)*100:.1f}%)")
    print(f"Average profit per trade: {trades_df['profit'].mean():.5f}")
    print(f"Average profit %: {trades_df['profit_pct'].mean():.2f}%")
    print(f"Total profit: {trades_df['profit'].sum():.5f}")

    # Handle bars_held properly
    if 'bars_held' in trades_df.columns:
        bars_held_numeric = pd.to_numeric(trades_df['bars_held'], errors='coerce')
        if not bars_held_numeric.isna().all():
            print(f"Average bars per trade: {bars_held_numeric.mean():.1f}")

    print("\nLast 5 trades:")
    print(trades_df.tail())

# Visualize Volatility Index and Volatility System
def plot_volatility_analysis(vi_df, entry_points, exit_points):
    """
    Create comprehensive visualization of Volatility Index and Trading System.

    Shows:
    1. Price chart with SAR and position indicators
    2. Volatility Index (ATR)
    3. Position and trade signals
    """
    fig, axes = plt.subplots(3, 1, figsize=(16, 12), height_ratios=[3, 1, 1])

    # 1. Price Chart with Volatility System
    ax1 = axes[0]
    x = np.arange(len(vi_df))

    # Plot OHLC candlesticks
    for i in range(len(vi_df)):
        color = 'g' if vi_df['close'].iloc[i] >= vi_df['open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [vi_df['low'].iloc[i], vi_df['high'].iloc[i]],
                 color=color, linewidth=1, alpha=0.7)
        rect = Rectangle((x[i]-0.3, min(vi_df['open'].iloc[i], vi_df['close'].iloc[i])),
                        0.6, abs(vi_df['close'].iloc[i] - vi_df['open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Plot SAR (Stop and Reverse) points
    # Only plot where position is active (non-zero)
    valid_mask = vi_df['position'] != 0
    long_mask = vi_df['position'] == 1
    short_mask = vi_df['position'] == -1

    # Plot SAR for long positions (below price)
    ax1.scatter(x[long_mask & valid_mask], vi_df.loc[long_mask & valid_mask, 'sar'],
                color='green', s=15, marker='o', label='SAR (Long)',
                zorder=10, edgecolors='darkgreen', linewidth=0.5)

    # Plot SAR for short positions (above price)
    ax1.scatter(x[short_mask & valid_mask], vi_df.loc[short_mask & valid_mask, 'sar'],
                color='red', s=15, marker='o', label='SAR (Short)',
                zorder=10, edgecolors='darkred', linewidth=0.5)

    # Plot SIC (Significant Close) as a line
    sic_valid = vi_df.loc[valid_mask, 'sic']
    x_valid = x[valid_mask]
    ax1.plot(x_valid, sic_valid, 'blue', linewidth=1, alpha=0.5, label='SIC', linestyle='--')

    # Mark entry and exit points
    for idx, price, action in entry_points:
        if 'Long' in action:
            ax1.annotate('↑', xy=(idx, price), xytext=(idx, price * 0.995),
                        fontsize=12, color='green', ha='center', weight='bold')
        else:
            ax1.annotate('↓', xy=(idx, price), xytext=(idx, price * 1.005),
                        fontsize=12, color='red', ha='center', weight='bold')

    # Shade background based on position
    for i in range(1, len(vi_df)):
        if vi_df['position'].iloc[i] == 1 and vi_df['position'].iloc[i-1] == 1:
            ax1.axvspan(i-1, i, alpha=0.1, color='green', zorder=0)
        elif vi_df['position'].iloc[i] == -1 and vi_df['position'].iloc[i-1] == -1:
            ax1.axvspan(i-1, i, alpha=0.1, color='red', zorder=0)

    ax1.set_ylabel('Price', fontsize=12)
    ax1.set_title('Wilder\'s Volatility System - Price Chart with SAR', fontsize=14)
    ax1.legend(loc='upper left', fontsize=10)
    ax1.grid(True, alpha=0.3)

    # 2. Volatility Index (ATR)
    ax2 = axes[1]

    # Plot ATR/VI
    ax2.plot(x, vi_df['atr_14'], 'purple', linewidth=1.5, label='ATR(14) / VI')
    ax2.fill_between(x, 0, vi_df['atr_14'], alpha=0.3, color='purple')

    # Plot ARC line (ATR × constant)
    ax2.plot(x, vi_df['arc'], 'orange', linewidth=1, linestyle='--',
             label='ARC (ATR × 3.0)', alpha=0.7)

    # Add average line
    atr_mean = vi_df['atr_14'][vi_df['atr_14'] > 0].mean()
    ax2.axhline(y=atr_mean, color='gray', linestyle=':', alpha=0.5,
                label=f'Avg: {atr_mean:.5f}')

    ax2.set_ylabel('Volatility Index', fontsize=12)
    ax2.set_title('Average True Range (14) - Volatility Index', fontsize=12)
    ax2.legend(loc='upper left', fontsize=9)
    ax2.grid(True, alpha=0.3)

    # 3. Position and Distance from SAR
    ax3 = axes[2]

    # Calculate distance from price to SAR
    distance_to_sar = np.zeros(len(vi_df))
    for i in range(len(vi_df)):
        if vi_df['position'].iloc[i] == 1:  # Long
            distance_to_sar[i] = vi_df['close'].iloc[i] - vi_df['sar'].iloc[i]
        elif vi_df['position'].iloc[i] == -1:  # Short
            distance_to_sar[i] = vi_df['sar'].iloc[i] - vi_df['close'].iloc[i]
        else:
            distance_to_sar[i] = 0

    # Convert to percentage of ATR
    distance_pct_atr = np.zeros(len(vi_df))
    for i in range(len(vi_df)):
        if vi_df['atr_14'].iloc[i] > 0:
            distance_pct_atr[i] = (distance_to_sar[i] / vi_df['atr_14'].iloc[i]) * 100

    # Plot distance as bars
    colors = ['green' if val > 0 else 'red' for val in distance_pct_atr]
    ax3.bar(x, distance_pct_atr, color=colors, alpha=0.7, width=0.8)

    # Add zero line and critical levels
    ax3.axhline(y=0, color='black', linestyle='-', linewidth=1)
    ax3.axhline(y=100, color='orange', linestyle='--', alpha=0.5,
                label='100% ATR')
    ax3.axhline(y=200, color='red', linestyle='--', alpha=0.5,
                label='200% ATR')

    # Mark position changes
    position_changes = vi_df['position'].diff() != 0
    change_indices = x[position_changes]
    for idx in change_indices:
        ax3.axvline(x=idx, color='gray', alpha=0.3, linestyle='--', linewidth=0.5)

    ax3.set_ylabel('Distance to SAR\n(% of ATR)', fontsize=12)
    ax3.set_xlabel('Bar', fontsize=12)
    ax3.set_title('Distance from Price to Stop (as % of ATR)', fontsize=12)
    ax3.legend(loc='upper left', fontsize=9)
    ax3.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

# Create the visualization
plot_volatility_analysis(vi_df, entry_points, exit_points)

# Additional analysis - Volatility regimes
def analyze_volatility_regimes(vi_df):
    """Analyze different volatility regimes"""
    # Calculate volatility percentiles
    atr_values = vi_df['atr_14'][vi_df['atr_14'] > 0]

    p25 = atr_values.quantile(0.25)
    p50 = atr_values.quantile(0.50)
    p75 = atr_values.quantile(0.75)

    # Classify volatility regimes
    vi_df['vol_regime'] = 'Unknown'
    mask = vi_df['atr_14'] > 0
    vi_df.loc[mask & (vi_df['atr_14'] <= p25), 'vol_regime'] = 'Low'
    vi_df.loc[mask & (vi_df['atr_14'] > p25) & (vi_df['atr_14'] <= p50), 'vol_regime'] = 'Below Average'
    vi_df.loc[mask & (vi_df['atr_14'] > p50) & (vi_df['atr_14'] <= p75), 'vol_regime'] = 'Above Average'
    vi_df.loc[mask & (vi_df['atr_14'] > p75), 'vol_regime'] = 'High'

    print("\n" + "="*60)
    print("VOLATILITY ANALYSIS SUMMARY")
    print("="*60)

    print(f"\nVolatility Index (ATR) Statistics:")
    print(f"  Current ATR: {vi_df['atr_14'].iloc[-1]:.5f}")
    print(f"  Average ATR: {atr_values.mean():.5f}")
    print(f"  Min ATR: {atr_values.min():.5f}")
    print(f"  Max ATR: {atr_values.max():.5f}")
    print(f"  Std Dev: {atr_values.std():.5f}")

    print(f"\nVolatility Percentiles:")
    print(f"  25th: {p25:.5f} (Low volatility threshold)")
    print(f"  50th: {p50:.5f} (Median)")
    print(f"  75th: {p75:.5f} (High volatility threshold)")

    print(f"\nVolatility Regime Distribution:")
    regime_counts = vi_df['vol_regime'].value_counts()
    for regime in ['Low', 'Below Average', 'Above Average', 'High']:
        if regime in regime_counts:
            count = regime_counts[regime]
            pct = (count / len(vi_df[mask])) * 100
            print(f"  {regime}: {count} bars ({pct:.1f}%)")

    print(f"\nCurrent Volatility Regime: {vi_df['vol_regime'].iloc[-1]}")

    # System performance by volatility regime
    print(f"\nSystem Performance by Volatility Regime:")
    if len(trades_df) > 0:
        # Map trades to volatility regimes
        for regime in ['Low', 'Below Average', 'Above Average', 'High']:
            regime_mask = vi_df['vol_regime'] == regime
            if regime_mask.any():
                # Count trades that started in this regime
                trade_count = 0
                total_profit = 0

                for _, trade in trades_df.iterrows():
                    entry_idx = vi_df[vi_df['date'] == trade['entry_date']].index[0]
                    if vi_df.loc[entry_idx, 'vol_regime'] == regime:
                        trade_count += 1
                        total_profit += trade['profit_pct']

                if trade_count > 0:
                    avg_profit = total_profit / trade_count
                    print(f"  {regime}: {trade_count} trades, Avg profit: {avg_profit:.2f}%")

# Analyze volatility regimes
analyze_volatility_regimes(vi_df)

# Final Comprehensive View - All Indicators Combined
def plot_comprehensive_wilder_analysis(df, vi_df, additional_asi_analysis, asi_values):
    """
    Create final comprehensive visualization combining all Wilder indicators:
    - Price with Parabolic SAR and Volatility System SAR
    - ASI with swing points
    - Volatility Index (ATR)
    - RSI (both price and ASI based)
    """
    fig, axes = plt.subplots(5, 1, figsize=(18, 16),
                            height_ratios=[3, 1, 1, 1, 1])

    x = np.arange(len(df))

    # 1. Price Chart with Multiple SAR Systems
    ax1 = axes[0]

    # Plot OHLC candlesticks
    for i in range(len(df)):
        color = 'g' if df['Close'].iloc[i] >= df['Open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [df['Low'].iloc[i], df['High'].iloc[i]],
                 color=color, linewidth=1, alpha=0.7)
        rect = Rectangle((x[i]-0.3, min(df['Open'].iloc[i], df['Close'].iloc[i])),
                        0.6, abs(df['Close'].iloc[i] - df['Open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Plot Parabolic SAR
    psar = additional_asi_analysis['psar'].values
    psar_position = additional_asi_analysis['psar_position'].values
    psar_long = psar_position == 1
    psar_short = psar_position == -1

    ax1.scatter(x[psar_long], psar[psar_long], color='lightgreen', s=10,
                marker='o', label='Parabolic SAR (L)', zorder=8, alpha=0.7)
    ax1.scatter(x[psar_short], psar[psar_short], color='lightcoral', s=10,
                marker='o', label='Parabolic SAR (S)', zorder=8, alpha=0.7)

    # Plot Volatility System SAR (larger markers)
    vi_valid = vi_df['position'] != 0
    vi_long = vi_df['position'] == 1
    vi_short = vi_df['position'] == -1

    ax1.scatter(x[vi_long & vi_valid], vi_df.loc[vi_long & vi_valid, 'sar'],
                color='darkgreen', s=20, marker='^', label='Volatility SAR (L)',
                zorder=10, edgecolors='black', linewidth=0.5)
    ax1.scatter(x[vi_short & vi_valid], vi_df.loc[vi_short & vi_valid, 'sar'],
                color='darkred', s=20, marker='v', label='Volatility SAR (S)',
                zorder=10, edgecolors='black', linewidth=0.5)

    ax1.set_ylabel('Price', fontsize=12)
    ax1.set_title('Wilder\'s Complete Technical Analysis System', fontsize=16, pad=20)
    ax1.legend(loc='upper left', fontsize=9, ncol=2)
    ax1.grid(True, alpha=0.3)

    # 2. ASI with Swing Points
    ax2 = axes[1]

    # Color array for swing points
    asi_colors = ['orange'] * len(asi_values)
    hsp_indices = [i for i in range(len(additional_asi_analysis))
                   if additional_asi_analysis.loc[i, 'is_HSP'] == 1]
    lsp_indices = [i for i in range(len(additional_asi_analysis))
                   if additional_asi_analysis.loc[i, 'is_LSP'] == 1]

    for idx in hsp_indices:
        asi_colors[idx] = 'purple'
    for idx in lsp_indices:
        asi_colors[idx] = 'blue'

    ax2.scatter(x, asi_values, c=asi_colors, s=3, alpha=0.7)
    ax2.axhline(y=0, color='gray', linestyle='-', alpha=0.3)

    # Add regime background
    regimes = additional_asi_analysis['Regime']
    regime_colors = {
        'Uptrend': 'green',
        'Downtrend': 'red',
        'Bull_Div': 'orange',
        'Bear_Div': 'purple'
    }

    for regime, color in regime_colors.items():
        mask = regimes == regime
        if mask.any():
            ax2.fill_between(x, ax2.get_ylim()[0], ax2.get_ylim()[1],
                           where=mask, alpha=0.1, color=color)

    ax2.set_ylabel('ASI', fontsize=10)
    ax2.set_title('Accumulation Swing Index with Swing Points', fontsize=11)
    ax2.grid(True, alpha=0.3)

    # 3. Volatility Index (ATR)
    ax3 = axes[2]

    ax3.plot(x, vi_df['atr_14'], 'purple', linewidth=1.5, label='VI/ATR(14)')
    ax3.fill_between(x, 0, vi_df['atr_14'], alpha=0.3, color='purple')

    # Add volatility regime colors - Fixed version
    vol_regime_colors = {
        'Low': 'lightblue',
        'Below Average': 'blue',
        'Above Average': 'orange',
        'High': 'red'
    }

    if 'vol_regime' in vi_df.columns:
        # Create a full-length array for each regime
        for regime, color in vol_regime_colors.items():
            mask = vi_df['vol_regime'] == regime
            if mask.any():
                # Create arrays of same length as x
                y_bottom = np.zeros(len(x))
                y_top = np.zeros(len(x))

                # Fill in values where mask is True
                y_top[mask] = vi_df.loc[mask, 'atr_14'].values

                ax3.fill_between(x, y_bottom, y_top,
                               alpha=0.2, color=color)

    ax3.set_ylabel('VI/ATR', fontsize=10)
    ax3.set_title('Volatility Index (Average True Range)', fontsize=11)
    ax3.legend(loc='upper left', fontsize=9)
    ax3.grid(True, alpha=0.3)

    # 4. Price RSI
    ax4 = axes[3]

    price_rsi = additional_asi_analysis['price_rsi']
    ax4.plot(x, price_rsi, 'blue', linewidth=1.2)
    ax4.fill_between(x, 50, price_rsi, where=price_rsi > 50,
                     alpha=0.3, color='green', interpolate=True)
    ax4.fill_between(x, 50, price_rsi, where=price_rsi < 50,
                     alpha=0.3, color='red', interpolate=True)

    # Overbought/Oversold zones
    ax4.axhline(y=70, color='red', linestyle='--', alpha=0.5)
    ax4.axhline(y=30, color='green', linestyle='--', alpha=0.5)
    ax4.axhline(y=50, color='gray', linestyle='-', alpha=0.3)
    ax4.fill_between(x, 70, 100, alpha=0.1, color='red')
    ax4.fill_between(x, 0, 30, alpha=0.1, color='green')

    ax4.set_ylabel('Price RSI', fontsize=10)
    ax4.set_ylim(0, 100)
    ax4.set_title('Relative Strength Index (Price-based)', fontsize=11)
    ax4.grid(True, alpha=0.3)

    # 5. ASI RSI
    ax5 = axes[4]

    asi_rsi = additional_asi_analysis['asi_rsi']
    ax5.plot(x, asi_rsi, 'purple', linewidth=1.2)
    ax5.fill_between(x, 50, asi_rsi, where=asi_rsi > 50,
                     alpha=0.3, color='green', interpolate=True)
    ax5.fill_between(x, 50, asi_rsi, where=asi_rsi < 50,
                     alpha=0.3, color='red', interpolate=True)

    # Overbought/Oversold zones
    ax5.axhline(y=70, color='red', linestyle='--', alpha=0.5)
    ax5.axhline(y=30, color='green', linestyle='--', alpha=0.5)
    ax5.axhline(y=50, color='gray', linestyle='-', alpha=0.3)
    ax5.fill_between(x, 70, 100, alpha=0.1, color='red')
    ax5.fill_between(x, 0, 30, alpha=0.1, color='green')

    ax5.set_ylabel('ASI RSI', fontsize=10)
    ax5.set_xlabel('Bar', fontsize=12)
    ax5.set_ylim(0, 100)
    ax5.set_title('Relative Strength Index (ASI-based)', fontsize=11)
    ax5.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

    # Print comprehensive summary
    print("\n" + "="*70)
    print("WILDER'S COMPLETE TECHNICAL ANALYSIS SYSTEM - SUMMARY")
    print("="*70)

    print(f"\nData Range: {len(df)} bars")
    print(f"Price Range: {df['Low'].min():.5f} to {df['High'].max():.5f}")
    print(f"Current Price: {df['Close'].iloc[-1]:.5f}")

    print("\n1. PARABOLIC SAR:")
    print(f"   Current Position: {'Long' if psar_position[-1] == 1 else 'Short'}")
    print(f"   Current SAR: {psar[-1]:.5f}")
    print(f"   Distance to SAR: {abs(df['Close'].iloc[-1] - psar[-1]):.5f}")

    print("\n2. VOLATILITY SYSTEM:")
    print(f"   Current Position: {'Long' if vi_df['position'].iloc[-1] == 1 else 'Short' if vi_df['position'].iloc[-1] == -1 else 'None'}")
    if vi_df['position'].iloc[-1] != 0:
        print(f"   Current SAR: {vi_df['sar'].iloc[-1]:.5f}")
        print(f"   Current SIC: {vi_df['sic'].iloc[-1]:.5f}")
        print(f"   Current ARC: {vi_df['arc'].iloc[-1]:.5f}")

    print("\n3. ACCUMULATION SWING INDEX:")
    print(f"   Current ASI: {asi_values[-1]:.2f}")
    print(f"   Total HSPs: {len(hsp_indices)}")
    print(f"   Total LSPs: {len(lsp_indices)}")
    print(f"   Current Regime: {regimes.iloc[-1] if regimes.iloc[-1] else 'None'}")

    print("\n4. VOLATILITY INDEX:")
    print(f"   Current ATR(14): {vi_df['atr_14'].iloc[-1]:.5f}")
    if 'vol_regime' in vi_df.columns:
        print(f"   Volatility Regime: {vi_df['vol_regime'].iloc[-1]}")

    print("\n5. RELATIVE STRENGTH INDEX:")
    if not np.isnan(price_rsi.iloc[-1]):
        print(f"   Price RSI: {price_rsi.iloc[-1]:.2f}")
        if price_rsi.iloc[-1] > 70:
            print("   → Overbought")
        elif price_rsi.iloc[-1] < 30:
            print("   → Oversold")

    if not np.isnan(asi_rsi.iloc[-1]):
        print(f"   ASI RSI: {asi_rsi.iloc[-1]:.2f}")
        if asi_rsi.iloc[-1] > 70:
            print("   → Overbought")
        elif asi_rsi.iloc[-1] < 30:
            print("   → Oversold")

    # Signal alignment
    print("\n6. SIGNAL ALIGNMENT:")
    signals = []

    # Parabolic SAR signal
    if psar_position[-1] == 1:
        signals.append(("Parabolic SAR", "Long"))
    else:
        signals.append(("Parabolic SAR", "Short"))

    # Volatility System signal
    if vi_df['position'].iloc[-1] == 1:
        signals.append(("Volatility System", "Long"))
    elif vi_df['position'].iloc[-1] == -1:
        signals.append(("Volatility System", "Short"))

    # ASI Regime signal
    if regimes.iloc[-1] == 'Uptrend':
        signals.append(("ASI Regime", "Bullish"))
    elif regimes.iloc[-1] == 'Downtrend':
        signals.append(("ASI Regime", "Bearish"))
    elif regimes.iloc[-1] == 'Bull_Div':
        signals.append(("ASI Regime", "Bullish Divergence"))
    elif regimes.iloc[-1] == 'Bear_Div':
        signals.append(("ASI Regime", "Bearish Divergence"))

    # RSI signals
    if not np.isnan(price_rsi.iloc[-1]):
        if price_rsi.iloc[-1] > 70:
            signals.append(("Price RSI", "Overbought/Bearish"))
        elif price_rsi.iloc[-1] < 30:
            signals.append(("Price RSI", "Oversold/Bullish"))

    print("\n   Current Signals:")
    for indicator, signal in signals:
        print(f"   - {indicator}: {signal}")

    # Count bullish vs bearish signals
    bullish_count = sum(1 for _, s in signals if 'Long' in s or 'Bullish' in s)
    bearish_count = sum(1 for _, s in signals if 'Short' in s or 'Bearish' in s)

    print(f"\n   Signal Summary: {bullish_count} Bullish, {bearish_count} Bearish")
    if bullish_count > bearish_count:
        print("   → Overall Bias: BULLISH")
    elif bearish_count > bullish_count:
        print("   → Overall Bias: BEARISH")
    else:
        print("   → Overall Bias: NEUTRAL")

# Create the comprehensive visualization
plot_comprehensive_wilder_analysis(df, vi_df, additional_asi_analysis, asi_values)

# Directional Movement Index (DMI) Implementation - Welles Wilder's Original Method
def calculate_directional_movement(df, period=14):
    """
    Calculate Directional Movement Index according to Welles Wilder's method.

    Includes:
    - +DM and -DM (Directional Movement)
    - TR (True Range)
    - +DI and -DI (Directional Indicators)
    - DX (Directional Index)
    - ADX (Average Directional Index)
    - ADXR (Average Directional Movement Rating)

    Parameters:
    - df: DataFrame with OHLC data
    - period: Period for calculations (default 14 as per Wilder)

    Returns:
    - Dictionary with all DMI components
    """
    n = len(df)

    # Initialize arrays
    plus_dm = np.zeros(n)
    minus_dm = np.zeros(n)
    true_range = np.zeros(n)

    # Calculate True Range for first bar
    true_range[0] = df['High'].iloc[0] - df['Low'].iloc[0]

    # Calculate +DM, -DM, and TR for each day
    for i in range(1, n):
        # Current and previous values
        high = df['High'].iloc[i]
        low = df['Low'].iloc[i]
        prev_high = df['High'].iloc[i-1]
        prev_low = df['Low'].iloc[i-1]
        prev_close = df['Close'].iloc[i-1]

        # Calculate potential directional movements
        up_move = high - prev_high
        down_move = prev_low - low

        # Determine +DM and -DM
        # Directional movement is either up or down, not both
        if up_move > down_move and up_move > 0:
            plus_dm[i] = up_move
            minus_dm[i] = 0
        elif down_move > up_move and down_move > 0:
            plus_dm[i] = 0
            minus_dm[i] = down_move
        else:
            plus_dm[i] = 0
            minus_dm[i] = 0

        # Inside day - no directional movement
        if high <= prev_high and low >= prev_low:
            plus_dm[i] = 0
            minus_dm[i] = 0

        # Calculate True Range
        high_low = high - low
        high_close = abs(high - prev_close)
        low_close = abs(low - prev_close)
        true_range[i] = max(high_low, high_close, low_close)

    # Calculate smoothed values using Wilder's method
    plus_dm14 = np.zeros(n)
    minus_dm14 = np.zeros(n)
    tr14 = np.zeros(n)

    # Initial values - simple sum for first 'period' days
    if n >= period:
        plus_dm14[period-1] = np.sum(plus_dm[:period])
        minus_dm14[period-1] = np.sum(minus_dm[:period])
        tr14[period-1] = np.sum(true_range[:period])

        # Subsequent values use Wilder's smoothing
        for i in range(period, n):
            plus_dm14[i] = plus_dm14[i-1] - (plus_dm14[i-1] / period) + plus_dm[i]
            minus_dm14[i] = minus_dm14[i-1] - (minus_dm14[i-1] / period) + minus_dm[i]
            tr14[i] = tr14[i-1] - (tr14[i-1] / period) + true_range[i]

    # Calculate Directional Indicators (+DI and -DI)
    plus_di = np.zeros(n)
    minus_di = np.zeros(n)

    for i in range(period-1, n):
        if tr14[i] != 0:
            plus_di[i] = (plus_dm14[i] / tr14[i]) * 100
            minus_di[i] = (minus_dm14[i] / tr14[i]) * 100

    # Calculate DX (Directional Index)
    dx = np.zeros(n)

    for i in range(period-1, n):
        di_sum = plus_di[i] + minus_di[i]
        if di_sum != 0:
            di_diff = abs(plus_di[i] - minus_di[i])
            dx[i] = (di_diff / di_sum) * 100

    # Calculate ADX (Average Directional Index)
    adx = np.zeros(n)

    # First ADX is simple average of first 'period' DX values
    if n >= 2 * period - 1:
        adx[2*period-2] = np.mean(dx[period-1:2*period-1])

        # Subsequent ADX values use Wilder's smoothing
        for i in range(2*period-1, n):
            adx[i] = (adx[i-1] * (period - 1) + dx[i]) / period

    # Calculate ADXR (Average Directional Movement Rating)
    adxr = np.zeros(n)

    for i in range(3*period-2, n):
        adxr[i] = (adx[i] + adx[i-period+1]) / 2

    return {
        'plus_dm': plus_dm,
        'minus_dm': minus_dm,
        'true_range': true_range,
        'plus_dm14': plus_dm14,
        'minus_dm14': minus_dm14,
        'tr14': tr14,
        'plus_di': plus_di,
        'minus_di': minus_di,
        'dx': dx,
        'adx': adx,
        'adxr': adxr
    }

# Calculate Directional Movement Index
dmi_data = calculate_directional_movement(df, period=14)

# Create ADX DataFrame
adx_df = pd.DataFrame({
    'date': df.index,
    'open': df['Open'],
    'high': df['High'],
    'low': df['Low'],
    'close': df['Close'],
    'plus_dm': dmi_data['plus_dm'],
    'minus_dm': dmi_data['minus_dm'],
    'true_range': dmi_data['true_range'],
    'plus_dm14': dmi_data['plus_dm14'],
    'minus_dm14': dmi_data['minus_dm14'],
    'tr14': dmi_data['tr14'],
    'plus_di': dmi_data['plus_di'],
    'minus_di': dmi_data['minus_di'],
    'dx': dmi_data['dx'],
    'adx': dmi_data['adx'],
    'adxr': dmi_data['adxr']
})

# Display sample data
print("Directional Movement Index Analysis Sample:")
print("\nFirst 30 rows (showing calculation buildup):")
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
print(adx_df[['date', 'plus_dm', 'minus_dm', 'true_range', 'plus_di', 'minus_di', 'dx', 'adx', 'adxr']].head(30))

print("\nLast 10 rows (current values):")
print(adx_df[['date', 'plus_di', 'minus_di', 'dx', 'adx', 'adxr']].tail(10))

# Visualize Directional Movement Index
def plot_directional_movement_analysis(df, adx_df):
    """
    Create comprehensive visualization of Directional Movement Index.

    Shows:
    1. Price chart with trend indicators
    2. +DI and -DI lines with crossovers
    3. ADX and ADXR lines
    4. DX histogram
    """
    fig, axes = plt.subplots(4, 1, figsize=(16, 14), height_ratios=[3, 1.5, 1.5, 1])

    x = np.arange(len(df))

    # 1. Price Chart
    ax1 = axes[0]

    # Plot OHLC candlesticks
    for i in range(len(df)):
        color = 'g' if df['Close'].iloc[i] >= df['Open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [df['Low'].iloc[i], df['High'].iloc[i]],
                 color=color, linewidth=1, alpha=0.7)
        rect = Rectangle((x[i]-0.3, min(df['Open'].iloc[i], df['Close'].iloc[i])),
                        0.6, abs(df['Close'].iloc[i] - df['Open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Shade background based on DI dominance
    plus_di = adx_df['plus_di'].values
    minus_di = adx_df['minus_di'].values

    for i in range(1, len(adx_df)):
        if plus_di[i] > minus_di[i] and plus_di[i-1] > minus_di[i-1]:
            ax1.axvspan(i-1, i, alpha=0.05, color='green', zorder=0)
        elif minus_di[i] > plus_di[i] and minus_di[i-1] > plus_di[i-1]:
            ax1.axvspan(i-1, i, alpha=0.05, color='red', zorder=0)

    ax1.set_ylabel('Price', fontsize=12)
    ax1.set_title("Welles Wilder's Directional Movement Index System", fontsize=14)
    ax1.grid(True, alpha=0.3)

    # 2. Directional Indicators (+DI and -DI)
    ax2 = axes[1]

    # Plot DI lines
    ax2.plot(x, plus_di, 'green', linewidth=1.5, label='+DI(14)', alpha=0.8)
    ax2.plot(x, minus_di, 'red', linewidth=1.5, label='-DI(14)', alpha=0.8)

    # Mark crossovers
    for i in range(1, len(adx_df)):
        # Bullish crossover (+DI crosses above -DI)
        if plus_di[i] > minus_di[i] and plus_di[i-1] <= minus_di[i-1]:
            ax2.scatter(i, plus_di[i], color='green', s=100, marker='^',
                       zorder=5, edgecolors='darkgreen', linewidth=2)
            ax1.axvline(x=i, color='green', alpha=0.3, linestyle='--', linewidth=1)

        # Bearish crossover (-DI crosses above +DI)
        elif minus_di[i] > plus_di[i] and minus_di[i-1] <= plus_di[i-1]:
            ax2.scatter(i, minus_di[i], color='red', s=100, marker='v',
                       zorder=5, edgecolors='darkred', linewidth=2)
            ax1.axvline(x=i, color='red', alpha=0.3, linestyle='--', linewidth=1)

    # Add reference lines
    ax2.axhline(y=25, color='gray', linestyle=':', alpha=0.5)
    ax2.axhline(y=50, color='gray', linestyle=':', alpha=0.5)

    ax2.set_ylabel('DI Value', fontsize=10)
    ax2.set_title('Directional Indicators (+DI and -DI)', fontsize=11)
    ax2.legend(loc='upper left', fontsize=9)
    ax2.grid(True, alpha=0.3)
    ax2.set_ylim(0, max(np.max(plus_di), np.max(minus_di)) * 1.1)

    # 3. ADX and ADXR
    ax3 = axes[2]

    adx = adx_df['adx'].values
    adxr = adx_df['adxr'].values

    # Plot ADX and ADXR
    ax3.plot(x, adx, 'blue', linewidth=1.5, label='ADX(14)', alpha=0.9)
    ax3.plot(x, adxr, 'purple', linewidth=1.5, label='ADXR', alpha=0.9, linestyle='--')

    # Fill areas to show trend strength
    ax3.fill_between(x, 0, adx, where=(adx < 20), alpha=0.2, color='gray',
                     label='Weak Trend (<20)')
    ax3.fill_between(x, 0, adx, where=(adx >= 20) & (adx < 40), alpha=0.2,
                     color='orange', label='Moderate Trend (20-40)')
    ax3.fill_between(x, 0, adx, where=(adx >= 40), alpha=0.2, color='red',
                     label='Strong Trend (>40)')

    # Reference lines
    ax3.axhline(y=20, color='gray', linestyle='--', alpha=0.5)
    ax3.axhline(y=40, color='gray', linestyle='--', alpha=0.5)

    # Mark extreme points
    if len(adx[adx > 0]) > 0:
        adx_peaks = []
        for i in range(1, len(adx)-1):
            if adx[i] > adx[i-1] and adx[i] > adx[i+1] and adx[i] > 40:
                adx_peaks.append(i)
                ax3.scatter(i, adx[i], color='red', s=50, zorder=5)

    ax3.set_ylabel('ADX/ADXR', fontsize=10)
    ax3.set_title('Average Directional Index (Trend Strength)', fontsize=11)
    ax3.legend(loc='upper left', fontsize=8, ncol=2)
    ax3.grid(True, alpha=0.3)
    ax3.set_ylim(0, max(50, np.max(adx[adx > 0]) * 1.1) if len(adx[adx > 0]) > 0 else 50)

    # 4. DX Histogram
    ax4 = axes[3]

    dx = adx_df['dx'].values

    # Plot DX as histogram
    colors = ['green' if plus_di[i] > minus_di[i] else 'red' for i in range(len(dx))]
    ax4.bar(x, dx, color=colors, alpha=0.6, width=0.8)

    # Add moving average of DX
    dx_ma = np.convolve(dx, np.ones(14)/14, mode='same')
    ax4.plot(x, dx_ma, 'black', linewidth=1, alpha=0.7, label='DX MA(14)')

    ax4.set_ylabel('DX', fontsize=10)
    ax4.set_xlabel('Bar', fontsize=12)
    ax4.set_title('Directional Index (DX)', fontsize=11)
    ax4.legend(loc='upper left', fontsize=9)
    ax4.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

# Create the visualization
plot_directional_movement_analysis(df, adx_df)

# Additional analysis
def analyze_directional_movement(adx_df):
    """Analyze DMI system signals and statistics"""

    print("\n" + "="*60)
    print("DIRECTIONAL MOVEMENT ANALYSIS SUMMARY")
    print("="*60)

    # Get valid data (after calculations stabilize)
    valid_mask = adx_df['adx'] > 0

    if valid_mask.any():
        plus_di = adx_df.loc[valid_mask, 'plus_di']
        minus_di = adx_df.loc[valid_mask, 'minus_di']
        adx = adx_df.loc[valid_mask, 'adx']
        adxr = adx_df.loc[valid_mask, 'adxr']

        print(f"\nCurrent Values:")
        print(f"  +DI(14): {plus_di.iloc[-1]:.2f}")
        print(f"  -DI(14): {minus_di.iloc[-1]:.2f}")
        print(f"  ADX(14): {adx.iloc[-1]:.2f}")
        if adxr.iloc[-1] > 0:
            print(f"  ADXR: {adxr.iloc[-1]:.2f}")

        # Current trend
        if plus_di.iloc[-1] > minus_di.iloc[-1]:
            print(f"  Trend Direction: BULLISH (+DI > -DI)")
        else:
            print(f"  Trend Direction: BEARISH (-DI > +DI)")

        # Trend strength
        current_adx = adx.iloc[-1]
        if current_adx < 20:
            strength = "WEAK/ABSENT"
        elif current_adx < 25:
            strength = "DEVELOPING"
        elif current_adx < 40:
            strength = "MODERATE"
        elif current_adx < 50:
            strength = "STRONG"
        else:
            strength = "VERY STRONG"

        print(f"  Trend Strength: {strength}")

        # DI crossovers
        print(f"\nDirectional Indicator Crossovers:")
        crossovers = []
        for i in range(1, len(plus_di)):
            if plus_di.iloc[i] > minus_di.iloc[i] and plus_di.iloc[i-1] <= minus_di.iloc[i-1]:
                crossovers.append((adx_df.index[valid_mask][i], 'Bullish'))
            elif minus_di.iloc[i] > plus_di.iloc[i] and minus_di.iloc[i-1] <= plus_di.iloc[i-1]:
                crossovers.append((adx_df.index[valid_mask][i], 'Bearish'))

        print(f"  Total crossovers: {len(crossovers)}")
        if len(crossovers) > 0:
            print(f"  Last 5 crossovers:")
            for idx, signal in crossovers[-5:]:
                print(f"    Bar {idx}: {signal}")

        # ADX statistics
        print(f"\nADX Statistics:")
        print(f"  Average: {adx.mean():.2f}")
        print(f"  Min: {adx.min():.2f}")
        print(f"  Max: {adx.max():.2f}")
        print(f"  Std Dev: {adx.std():.2f}")

        # Time in different trend strengths
        weak_pct = (adx < 20).sum() / len(adx) * 100
        moderate_pct = ((adx >= 20) & (adx < 40)).sum() / len(adx) * 100
        strong_pct = (adx >= 40).sum() / len(adx) * 100

        print(f"\nTrend Strength Distribution:")
        print(f"  Weak/No Trend (<20): {weak_pct:.1f}%")
        print(f"  Moderate Trend (20-40): {moderate_pct:.1f}%")
        print(f"  Strong Trend (>40): {strong_pct:.1f}%")

        # Current market assessment
        print(f"\nMarket Assessment:")
        di_diff = abs(plus_di.iloc[-1] - minus_di.iloc[-1])

        if current_adx > 40 and di_diff > 20:
            print("  → Strong trending market - favorable for trend-following systems")
        elif current_adx > 25 and di_diff > 10:
            print("  → Moderate trending market - trend-following may work")
        elif current_adx < 20:
            print("  → Non-trending/ranging market - avoid trend-following systems")
        else:
            print("  → Weak or developing trend - use caution")

        # ADX turning points
        adx_values = adx.values
        adx_turning_points = []

        for i in range(2, len(adx_values)-1):
            # Peak
            if adx_values[i] > adx_values[i-1] and adx_values[i] > adx_values[i+1] and adx_values[i] > 30:
                adx_turning_points.append((i, 'Peak', adx_values[i]))
            # Trough
            elif adx_values[i] < adx_values[i-1] and adx_values[i] < adx_values[i+1] and adx_values[i] < 25:
                adx_turning_points.append((i, 'Trough', adx_values[i]))

        if adx_turning_points:
            print(f"\nADX Turning Points (last 5):")
            for idx, turn_type, value in adx_turning_points[-5:]:
                print(f"  Bar {adx_df.index[valid_mask][idx]}: {turn_type} at {value:.2f}")

# Analyze the system
analyze_directional_movement(adx_df)

# Ultimate Comprehensive Wilder System - All Indicators Combined
def plot_ultimate_wilder_system(df, vi_df, adx_df, additional_asi_analysis, asi_values):
    """
    Create the ultimate comprehensive visualization with ALL Wilder indicators:
    - Price with multiple SAR systems
    - Directional Movement Index (+DI/-DI, ADX)
    - ASI with swing points
    - Volatility Index (ATR)
    - RSI (price-based)
    """
    fig, axes = plt.subplots(6, 1, figsize=(18, 20),
                            height_ratios=[3, 1.5, 1.5, 1, 1, 1])

    x = np.arange(len(df))

    # 1. Price Chart with Multiple Systems
    ax1 = axes[0]

    # Plot OHLC candlesticks
    for i in range(len(df)):
        color = 'g' if df['Close'].iloc[i] >= df['Open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [df['Low'].iloc[i], df['High'].iloc[i]],
                 color=color, linewidth=1, alpha=0.7)
        rect = Rectangle((x[i]-0.3, min(df['Open'].iloc[i], df['Close'].iloc[i])),
                        0.6, abs(df['Close'].iloc[i] - df['Open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Plot Parabolic SAR
    psar = additional_asi_analysis['psar'].values
    psar_position = additional_asi_analysis['psar_position'].values
    psar_long = psar_position == 1
    psar_short = psar_position == -1

    ax1.scatter(x[psar_long], psar[psar_long], color='lightgreen', s=8,
                marker='o', label='Parabolic SAR (L)', zorder=8, alpha=0.6)
    ax1.scatter(x[psar_short], psar[psar_short], color='lightcoral', s=8,
                marker='o', label='Parabolic SAR (S)', zorder=8, alpha=0.6)

    # Plot Volatility System SAR
    vi_valid = vi_df['position'] != 0
    vi_long = vi_df['position'] == 1
    vi_short = vi_df['position'] == -1

    ax1.scatter(x[vi_long & vi_valid], vi_df.loc[vi_long & vi_valid, 'sar'],
                color='darkgreen', s=15, marker='^', label='Volatility SAR (L)',
                zorder=10, edgecolors='black', linewidth=0.5)
    ax1.scatter(x[vi_short & vi_valid], vi_df.loc[vi_short & vi_valid, 'sar'],
                color='darkred', s=15, marker='v', label='Volatility SAR (S)',
                zorder=10, edgecolors='black', linewidth=0.5)

    # Shade background based on DI dominance
    plus_di = adx_df['plus_di'].values
    minus_di = adx_df['minus_di'].values

    for i in range(1, len(adx_df)):
        if plus_di[i] > minus_di[i] and plus_di[i-1] > minus_di[i-1]:
            ax1.axvspan(i-1, i, alpha=0.03, color='green', zorder=0)
        elif minus_di[i] > plus_di[i] and minus_di[i-1] > plus_di[i-1]:
            ax1.axvspan(i-1, i, alpha=0.03, color='red', zorder=0)

    ax1.set_ylabel('Price', fontsize=12)
    ax1.set_title("Wilder's Complete Technical Trading System - All Indicators", fontsize=16, pad=20)
    ax1.legend(loc='upper left', fontsize=8, ncol=2)
    ax1.grid(True, alpha=0.3)

    # 2. Directional Movement Index
    ax2 = axes[1]

    ax2.plot(x, plus_di, 'green', linewidth=1.2, label='+DI(14)', alpha=0.8)
    ax2.plot(x, minus_di, 'red', linewidth=1.2, label='-DI(14)', alpha=0.8)

    # Mark crossovers
    for i in range(1, len(adx_df)):
        if plus_di[i] > minus_di[i] and plus_di[i-1] <= minus_di[i-1]:
            ax2.scatter(i, plus_di[i], color='green', s=80, marker='^',
                       zorder=5, edgecolors='darkgreen', linewidth=1.5)
        elif minus_di[i] > plus_di[i] and minus_di[i-1] <= plus_di[i-1]:
            ax2.scatter(i, minus_di[i], color='red', s=80, marker='v',
                       zorder=5, edgecolors='darkred', linewidth=1.5)

    ax2.axhline(y=25, color='gray', linestyle=':', alpha=0.5)
    ax2.set_ylabel('DI', fontsize=10)
    ax2.set_title('Directional Indicators (+DI and -DI)', fontsize=11)
    ax2.legend(loc='upper left', fontsize=8)
    ax2.grid(True, alpha=0.3)
    ax2.set_ylim(0, max(np.max(plus_di), np.max(minus_di)) * 1.1)

    # 3. ADX
    ax3 = axes[2]

    adx = adx_df['adx'].values
    adxr = adx_df['adxr'].values

    ax3.plot(x, adx, 'blue', linewidth=1.5, label='ADX(14)', alpha=0.9)
    ax3.plot(x, adxr, 'purple', linewidth=1.2, label='ADXR', alpha=0.8, linestyle='--')

    # Fill trend strength zones
    ax3.fill_between(x, 0, adx, where=(adx < 20), alpha=0.2, color='gray')
    ax3.fill_between(x, 0, adx, where=(adx >= 20) & (adx < 40), alpha=0.2, color='orange')
    ax3.fill_between(x, 0, adx, where=(adx >= 40), alpha=0.2, color='red')

    ax3.axhline(y=20, color='gray', linestyle='--', alpha=0.5)
    ax3.axhline(y=40, color='gray', linestyle='--', alpha=0.5)

    ax3.set_ylabel('ADX', fontsize=10)
    ax3.set_title('Average Directional Index (Trend Strength)', fontsize=11)
    ax3.legend(loc='upper left', fontsize=8)
    ax3.grid(True, alpha=0.3)
    ax3.set_ylim(0, max(50, np.max(adx[adx > 0]) * 1.1) if len(adx[adx > 0]) > 0 else 50)

    # 4. ASI with Swing Points
    ax4 = axes[3]

    # Color array for swing points
    asi_colors = ['orange'] * len(asi_values)
    hsp_indices = [i for i in range(len(additional_asi_analysis))
                   if additional_asi_analysis.loc[i, 'is_HSP'] == 1]
    lsp_indices = [i for i in range(len(additional_asi_analysis))
                   if additional_asi_analysis.loc[i, 'is_LSP'] == 1]

    for idx in hsp_indices:
        asi_colors[idx] = 'purple'
    for idx in lsp_indices:
        asi_colors[idx] = 'blue'

    ax4.scatter(x, asi_values, c=asi_colors, s=2, alpha=0.7)
    ax4.axhline(y=0, color='gray', linestyle='-', alpha=0.3)

    ax4.set_ylabel('ASI', fontsize=10)
    ax4.set_title('Accumulation Swing Index', fontsize=11)
    ax4.grid(True, alpha=0.3)

    # 5. Volatility Index
    ax5 = axes[4]

    ax5.plot(x, vi_df['atr_14'], 'purple', linewidth=1.5, label='VI/ATR(14)')
    ax5.fill_between(x, 0, vi_df['atr_14'], alpha=0.3, color='purple')

    atr_mean = vi_df['atr_14'][vi_df['atr_14'] > 0].mean()
    ax5.axhline(y=atr_mean, color='gray', linestyle=':', alpha=0.5,
                label=f'Avg: {atr_mean:.5f}')

    ax5.set_ylabel('VI/ATR', fontsize=10)
    ax5.set_title('Volatility Index', fontsize=11)
    ax5.legend(loc='upper left', fontsize=8)
    ax5.grid(True, alpha=0.3)

    # 6. RSI
    ax6 = axes[5]

    price_rsi = additional_asi_analysis['price_rsi']
    ax6.plot(x, price_rsi, 'blue', linewidth=1.2)
    ax6.fill_between(x, 50, price_rsi, where=price_rsi > 50,
                     alpha=0.3, color='green', interpolate=True)
    ax6.fill_between(x, 50, price_rsi, where=price_rsi < 50,
                     alpha=0.3, color='red', interpolate=True)

    ax6.axhline(y=70, color='red', linestyle='--', alpha=0.5)
    ax6.axhline(y=30, color='green', linestyle='--', alpha=0.5)
    ax6.axhline(y=50, color='gray', linestyle='-', alpha=0.3)
    ax6.fill_between(x, 70, 100, alpha=0.1, color='red')
    ax6.fill_between(x, 0, 30, alpha=0.1, color='green')

    ax6.set_ylabel('RSI', fontsize=10)
    ax6.set_xlabel('Bar', fontsize=12)
    ax6.set_ylim(0, 100)
    ax6.set_title('Relative Strength Index', fontsize=11)
    ax6.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

    # Print comprehensive signal summary
    print("\n" + "="*70)
    print("WILDER'S COMPLETE SYSTEM - SIGNAL SUMMARY")
    print("="*70)

    print(f"\nCurrent Price: {df['Close'].iloc[-1]:.5f}")

    # Collect all signals
    signals = []

    # 1. DMI Signals
    if plus_di[-1] > minus_di[-1]:
        signals.append(("DMI Direction", "BULLISH", f"+DI({plus_di[-1]:.1f}) > -DI({minus_di[-1]:.1f})"))
    else:
        signals.append(("DMI Direction", "BEARISH", f"-DI({minus_di[-1]:.1f}) > +DI({plus_di[-1]:.1f})"))

    if adx[-1] > 0:
        if adx[-1] > 40:
            signals.append(("DMI Strength", "STRONG TREND", f"ADX={adx[-1]:.1f}"))
        elif adx[-1] > 25:
            signals.append(("DMI Strength", "MODERATE TREND", f"ADX={adx[-1]:.1f}"))
        else:
            signals.append(("DMI Strength", "WEAK/NO TREND", f"ADX={adx[-1]:.1f}"))

    # 2. Parabolic SAR
    if psar_position[-1] == 1:
        signals.append(("Parabolic SAR", "LONG", f"SAR={psar[-1]:.5f}"))
    else:
        signals.append(("Parabolic SAR", "SHORT", f"SAR={psar[-1]:.5f}"))

    # 3. Volatility System
    if vi_df['position'].iloc[-1] == 1:
        signals.append(("Volatility System", "LONG", f"SAR={vi_df['sar'].iloc[-1]:.5f}"))
    elif vi_df['position'].iloc[-1] == -1:
        signals.append(("Volatility System", "SHORT", f"SAR={vi_df['sar'].iloc[-1]:.5f}"))

    # 4. ASI Regime
    current_regime = additional_asi_analysis['Regime'].iloc[-1]
    if current_regime:
        regime_bias = {
            'Uptrend': 'BULLISH',
            'Downtrend': 'BEARISH',
            'Bull_Div': 'BULLISH DIV',
            'Bear_Div': 'BEARISH DIV'
        }
        signals.append(("ASI Regime", regime_bias.get(current_regime, current_regime),
                       f"ASI={asi_values[-1]:.1f}"))

    # 5. RSI
    if not np.isnan(price_rsi.iloc[-1]):
        rsi_val = price_rsi.iloc[-1]
        if rsi_val > 70:
            signals.append(("RSI", "OVERBOUGHT", f"RSI={rsi_val:.1f}"))
        elif rsi_val < 30:
            signals.append(("RSI", "OVERSOLD", f"RSI={rsi_val:.1f}"))
        else:
            signals.append(("RSI", "NEUTRAL", f"RSI={rsi_val:.1f}"))

    # 6. Volatility Level
    current_atr = vi_df['atr_14'].iloc[-1]
    if 'vol_regime' in vi_df.columns:
        signals.append(("Volatility", vi_df['vol_regime'].iloc[-1].upper(),
                       f"ATR={current_atr:.5f}"))

    # Print signals
    print("\nCurrent Signals:")
    for indicator, signal, details in signals:
        print(f"  {indicator:.<20} {signal:<15} [{details}]")

    # Calculate consensus
    bullish_count = sum(1 for _, s, _ in signals if 'BULL' in s or 'LONG' in s or 'OVERSOLD' in s)
    bearish_count = sum(1 for _, s, _ in signals if 'BEAR' in s or 'SHORT' in s or 'OVERBOUGHT' in s)

    print(f"\nSignal Consensus: {bullish_count} Bullish, {bearish_count} Bearish")

    if bullish_count > bearish_count + 1:
        print("→ OVERALL BIAS: STRONGLY BULLISH")
    elif bullish_count > bearish_count:
        print("→ OVERALL BIAS: MODERATELY BULLISH")
    elif bearish_count > bullish_count + 1:
        print("→ OVERALL BIAS: STRONGLY BEARISH")
    elif bearish_count > bullish_count:
        print("→ OVERALL BIAS: MODERATELY BEARISH")
    else:
        print("→ OVERALL BIAS: NEUTRAL/MIXED")

    # Trading recommendations based on Wilder's philosophy
    print("\nTrading Recommendations (based on Wilder's systems):")

    if adx[-1] > 25:
        print("✓ Market is trending - trend-following systems recommended")
        if plus_di[-1] > minus_di[-1]:
            print("  → Look for long opportunities on pullbacks")
        else:
            print("  → Look for short opportunities on rallies")
    else:
        print("✗ Market is not trending - avoid trend-following systems")
        print("  → Consider range-trading or wait for trend development")

    if current_atr > atr_mean * 1.5:
        print("⚠ High volatility - use wider stops")
    elif current_atr < atr_mean * 0.5:
        print("⚠ Low volatility - potential breakout ahead")

# Create the ultimate visualization
plot_ultimate_wilder_system(df, vi_df, adx_df, additional_asi_analysis, asi_values)

# Commodity Selection Index (CSI) - Wilder's Market Selection Tool
def calculate_commodity_selection_index(adx_df, vi_df,
                                      dollar_value_per_point=1.0,
                                      margin_requirement=1000.0,
                                      commission=5.0):
    """
    Calculate Commodity Selection Index according to Wilder's formula.

    CSI = ADXR × ATR14 × [(V / sqrt(M)) × (1 / (150 + C))] × 100

    Where:
    - ADXR = Average Directional Movement Index Rating
    - ATR14 = 14-day Average True Range
    - V = Dollar value of a 1 point move
    - M = Margin requirement in dollars
    - C = Commission in dollars

    For forex/synthetic data, we use normalized values.
    """

    # Get the latest valid ADXR and ATR values
    valid_adxr_mask = adx_df['adxr'] > 0
    valid_atr_mask = vi_df['atr_14'] > 0

    if not valid_adxr_mask.any() or not valid_atr_mask.any():
        print("Insufficient data for CSI calculation")
        return None

    # Get latest values
    current_adxr = adx_df.loc[valid_adxr_mask, 'adxr'].iloc[-1]
    current_atr = vi_df.loc[valid_atr_mask, 'atr_14'].iloc[-1]

    # Calculate CSI components
    k_factor = (dollar_value_per_point / np.sqrt(margin_requirement)) * (1 / (150 + commission))

    # CSI calculation
    csi = current_adxr * current_atr * k_factor * 100

    # Create CSI time series
    csi_series = []

    for i in range(len(adx_df)):
        if adx_df['adxr'].iloc[i] > 0 and i < len(vi_df) and vi_df['atr_14'].iloc[i] > 0:
            csi_val = adx_df['adxr'].iloc[i] * vi_df['atr_14'].iloc[i] * k_factor * 100
            csi_series.append(csi_val)
        else:
            csi_series.append(np.nan)

    return {
        'current_csi': csi,
        'csi_series': csi_series,
        'adxr': current_adxr,
        'atr': current_atr,
        'k_factor': k_factor
    }

# Calculate CSI
csi_data = calculate_commodity_selection_index(adx_df, vi_df)

if csi_data:
    # Add CSI to dataframe
    adx_df['csi'] = csi_data['csi_series']

    # Plot CSI
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 8), height_ratios=[2, 1])

    x = np.arange(len(adx_df))

    # Plot price
    ax1.plot(x, df['Close'], 'black', linewidth=1, alpha=0.8)
    ax1.set_ylabel('Price', fontsize=11)
    ax1.set_title('Commodity Selection Index (CSI) - Market Selection Tool', fontsize=14)
    ax1.grid(True, alpha=0.3)

    # Plot CSI
    csi_values = np.array(csi_data['csi_series'])
    valid_csi = ~np.isnan(csi_values)

    if valid_csi.any():
        ax2.plot(x[valid_csi], csi_values[valid_csi], 'purple', linewidth=1.5, label='CSI')
        ax2.fill_between(x[valid_csi], 0, csi_values[valid_csi], alpha=0.3, color='purple')

        # Add average line
        csi_mean = np.nanmean(csi_values)
        ax2.axhline(y=csi_mean, color='gray', linestyle='--', alpha=0.5,
                    label=f'Average: {csi_mean:.2f}')

        # Highlight high CSI periods
        high_csi_threshold = np.nanpercentile(csi_values, 75)
        ax2.axhline(y=high_csi_threshold, color='green', linestyle=':', alpha=0.5,
                    label=f'High (75%): {high_csi_threshold:.2f}')

        ax2.set_ylabel('CSI', fontsize=11)
        ax2.set_xlabel('Bar', fontsize=11)
        ax2.legend(loc='upper left', fontsize=9)
        ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

    # Print CSI analysis
    print("\n" + "="*60)
    print("COMMODITY SELECTION INDEX (CSI) ANALYSIS")
    print("="*60)

    print(f"\nCurrent CSI: {csi_data['current_csi']:.2f}")
    print(f"Components:")
    print(f"  ADXR: {csi_data['adxr']:.2f}")
    print(f"  ATR(14): {csi_data['atr']:.5f}")
    print(f"  K-factor: {csi_data['k_factor']:.6f}")

    # CSI statistics
    valid_csi_values = csi_values[valid_csi]
    if len(valid_csi_values) > 0:
        print(f"\nCSI Statistics:")
        print(f"  Average: {np.mean(valid_csi_values):.2f}")
        print(f"  Min: {np.min(valid_csi_values):.2f}")
        print(f"  Max: {np.max(valid_csi_values):.2f}")
        print(f"  Std Dev: {np.std(valid_csi_values):.2f}")

        # Percentiles
        p25 = np.percentile(valid_csi_values, 25)
        p50 = np.percentile(valid_csi_values, 50)
        p75 = np.percentile(valid_csi_values, 75)
        p90 = np.percentile(valid_csi_values, 90)

        print(f"\nCSI Percentiles:")
        print(f"  25th: {p25:.2f}")
        print(f"  50th: {p50:.2f}")
        print(f"  75th: {p75:.2f}")
        print(f"  90th: {p90:.2f}")

        # Current ranking
        current_percentile = (valid_csi_values <= csi_data['current_csi']).sum() / len(valid_csi_values) * 100
        print(f"\nCurrent CSI Percentile: {current_percentile:.1f}%")

        # Trading recommendation based on CSI
        print(f"\nCSI-Based Trading Recommendation:")
        if current_percentile >= 90:
            print("★★★★★ EXCELLENT - Top 10% for trend-following")
            print("→ This market shows exceptional directional movement relative to volatility")
            print("→ Highly favorable for Wilder's trend-following systems")
        elif current_percentile >= 75:
            print("★★★★☆ VERY GOOD - Top 25% for trend-following")
            print("→ Strong directional characteristics")
            print("→ Well-suited for trend-following systems")
        elif current_percentile >= 50:
            print("★★★☆☆ MODERATE - Above average")
            print("→ Reasonable trending characteristics")
            print("→ Trend-following may work with proper risk management")
        elif current_percentile >= 25:
            print("★★☆☆☆ BELOW AVERAGE")
            print("→ Weak directional movement relative to volatility")
            print("→ Consider other markets or wait for improvement")
        else:
            print("★☆☆☆☆ POOR - Bottom 25%")
            print("→ Very poor risk/reward for trend-following")
            print("→ Avoid trend-following systems in this market")

    # Final summary
    print("\n" + "="*60)
    print("WILDER'S COMPLETE TECHNICAL ANALYSIS SUMMARY")
    print("="*60)

    print("\nKey Metrics:")
    print(f"  Price: {df['Close'].iloc[-1]:.5f}")
    print(f"  Volatility (ATR): {vi_df['atr_14'].iloc[-1]:.5f}")
    print(f"  Trend Strength (ADX): {adx_df['adx'].iloc[-1]:.2f}")
    print(f"  Market Selection (CSI): {csi_data['current_csi']:.2f}")

    print("\nSystem Status:")
    print(f"  Parabolic SAR: {'LONG' if additional_asi_analysis['psar_position'].iloc[-1] == 1 else 'SHORT'}")
    print(f"  Volatility System: {'LONG' if vi_df['position'].iloc[-1] == 1 else 'SHORT' if vi_df['position'].iloc[-1] == -1 else 'FLAT'}")
    print(f"  DMI Direction: {'BULLISH' if adx_df['plus_di'].iloc[-1] > adx_df['minus_di'].iloc[-1] else 'BEARISH'}")
    print(f"  RSI: {additional_asi_analysis['price_rsi'].iloc[-1]:.1f}")

    print("\n" + "="*60)
    print("END OF WILDER'S NEW CONCEPTS IN TECHNICAL TRADING SYSTEMS")
    print("="*60)

# Momentum Concept and Trend Balance Point System - Welles Wilder's Original Method
def calculate_momentum_and_tbp(df, target_multiplier=2.0, stop_multiplier=1.0):
    """
    Calculate Momentum Factor and Trend Balance Point System according to Wilder's method.

    The system uses:
    - Momentum Factor (MF) = Today's Close - Yesterday's Close
    - Trend Balance Point (TBP) for position determination
    - True Range for targets and stops

    Parameters:
    - df: DataFrame with OHLC data
    - target_multiplier: Multiplier for TR to calculate target (default 2.0)
    - stop_multiplier: Multiplier for TR to calculate stop (default 1.0)

    Returns:
    - Dictionary with all momentum system components
    """
    n = len(df)

    # Initialize arrays
    momentum_factor = np.zeros(n)
    true_range = np.zeros(n)
    tbp = np.zeros(n)
    position = np.zeros(n)  # 1 for long, -1 for short, 0 for flat

    # Calculate True Range for first bar
    true_range[0] = df['High'].iloc[0] - df['Low'].iloc[0]

    # Calculate Momentum Factor and True Range
    for i in range(1, n):
        # Momentum Factor = Close today - Close yesterday
        momentum_factor[i] = df['Close'].iloc[i] - df['Close'].iloc[i-1]

        # True Range calculation
        high_low = df['High'].iloc[i] - df['Low'].iloc[i]
        high_close = abs(df['High'].iloc[i] - df['Close'].iloc[i-1])
        low_close = abs(df['Low'].iloc[i] - df['Close'].iloc[i-1])
        true_range[i] = max(high_low, high_close, low_close)

    # Calculate Trend Balance Point (TBP)
    # Need at least 3 days to start (2 previous MFs + current)
    for i in range(2, n):
        # Get the two previous momentum factors
        mf_1 = momentum_factor[i-1]
        mf_2 = momentum_factor[i-2]

        # Determine position based on current close vs TBP
        if i > 2 and tbp[i-1] > 0:
            if df['Close'].iloc[i] > tbp[i-1]:
                position[i] = 1  # Long
            elif df['Close'].iloc[i] < tbp[i-1]:
                position[i] = -1  # Short
            else:
                position[i] = position[i-1]  # No change
        else:
            # Initial position based on momentum
            if momentum_factor[i] > max(mf_1, mf_2):
                position[i] = 1
            elif momentum_factor[i] < min(mf_1, mf_2):
                position[i] = -1
            else:
                position[i] = position[i-1] if i > 0 else 0

        # Calculate TBP for next day
        if position[i] == 1:  # Long position
            # Use the lower of the two previous MFs
            tbp[i] = df['Close'].iloc[i] + min(mf_1, mf_2)
        elif position[i] == -1:  # Short position
            # Use the higher of the two previous MFs
            tbp[i] = df['Close'].iloc[i] + max(mf_1, mf_2)
        else:
            tbp[i] = df['Close'].iloc[i]  # Neutral

    # Calculate targets and stops
    target = np.zeros(n)
    stop = np.zeros(n)

    for i in range(1, n):
        if position[i] == 1:  # Long
            target[i] = df['Close'].iloc[i] + true_range[i] * target_multiplier
            stop[i] = df['Close'].iloc[i] - true_range[i] * stop_multiplier
        elif position[i] == -1:  # Short
            target[i] = df['Close'].iloc[i] - true_range[i] * target_multiplier
            stop[i] = df['Close'].iloc[i] + true_range[i] * stop_multiplier

    return {
        'momentum_factor': momentum_factor,
        'true_range': true_range,
        'tbp': tbp,
        'position': position,
        'target': target,
        'stop': stop
    }

# Calculate Momentum and TBP System
momentum_data = calculate_momentum_and_tbp(df)

# Create Momentum DataFrame
momentum_df = pd.DataFrame({
    'date': df.index,
    'open': df['Open'],
    'high': df['High'],
    'low': df['Low'],
    'close': df['Close'],
    'momentum_factor': momentum_data['momentum_factor'],
    'true_range': momentum_data['true_range'],
    'tbp': momentum_data['tbp'],
    'position': momentum_data['position'],
    'target': momentum_data['target'],
    'stop': momentum_data['stop']
})

# Display sample data
print("Momentum Concept and Trend Balance Point System Sample:")
print("\nFirst 20 rows:")
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
print(momentum_df[['date', 'close', 'momentum_factor', 'tbp', 'position', 'target', 'stop']].head(20))

print("\nLast 10 rows:")
print(momentum_df[['date', 'close', 'momentum_factor', 'tbp', 'position']].tail(10))

# Visualize Momentum Concept and Trend Balance Point System
def plot_momentum_tbp_analysis(df, momentum_df):
    """
    Create comprehensive visualization of Momentum and TBP System.

    Shows:
    1. Price chart with TBP line and position shading
    2. Momentum Factor histogram
    3. Position indicator with targets/stops
    """
    fig, axes = plt.subplots(3, 1, figsize=(16, 12), height_ratios=[3, 1.5, 1])

    x = np.arange(len(df))

    # 1. Price Chart with TBP
    ax1 = axes[0]

    # Plot OHLC candlesticks
    for i in range(len(df)):
        color = 'g' if df['Close'].iloc[i] >= df['Open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [df['Low'].iloc[i], df['High'].iloc[i]],
                 color=color, linewidth=1, alpha=0.7)
        rect = Rectangle((x[i]-0.3, min(df['Open'].iloc[i], df['Close'].iloc[i])),
                        0.6, abs(df['Close'].iloc[i] - df['Open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Plot TBP line
    tbp_mask = momentum_df['tbp'] > 0
    ax1.plot(x[tbp_mask], momentum_df.loc[tbp_mask, 'tbp'],
             'blue', linewidth=2, label='TBP (Trend Balance Point)', alpha=0.8)

    # Shade background based on position
    position = momentum_df['position'].values
    for i in range(1, len(momentum_df)):
        if position[i] == 1 and position[i-1] == 1:  # Long
            ax1.axvspan(i-1, i, alpha=0.05, color='green', zorder=0)
        elif position[i] == -1 and position[i-1] == -1:  # Short
            ax1.axvspan(i-1, i, alpha=0.05, color='red', zorder=0)

    # Mark position changes
    for i in range(1, len(momentum_df)):
        if position[i] != position[i-1] and position[i] != 0:
            if position[i] == 1:
                ax1.scatter(i, df['Low'].iloc[i] * 0.995,
                           color='green', s=100, marker='^', zorder=5)
            else:
                ax1.scatter(i, df['High'].iloc[i] * 1.005,
                           color='red', s=100, marker='v', zorder=5)

    ax1.set_ylabel('Price', fontsize=12)
    ax1.set_title("Wilder's Momentum Concept and Trend Balance Point System", fontsize=14)
    ax1.legend(loc='upper left', fontsize=10)
    ax1.grid(True, alpha=0.3)

    # 2. Momentum Factor
    ax2 = axes[1]

    mf = momentum_df['momentum_factor'].values
    colors = ['green' if val > 0 else 'red' for val in mf]
    bars = ax2.bar(x, mf, color=colors, alpha=0.7, width=0.8)

    # Add zero line
    ax2.axhline(y=0, color='black', linestyle='-', linewidth=1)

    # Add acceleration/deceleration indicators
    # Calculate momentum of momentum (acceleration)
    mf_acceleration = np.zeros(len(mf))
    for i in range(1, len(mf)):
        mf_acceleration[i] = mf[i] - mf[i-1]

    # Plot acceleration as line
    ax2_twin = ax2.twinx()
    ax2_twin.plot(x, mf_acceleration, 'purple', linewidth=1,
                  alpha=0.6, label='MF Acceleration')
    ax2_twin.set_ylabel('MF Acceleration', fontsize=10, color='purple')
    ax2_twin.tick_params(axis='y', labelcolor='purple')

    # Highlight momentum extremes
    if len(mf) > 2:
        for i in range(2, len(mf)):
            # Check if MF is higher than both previous MFs (bullish signal)
            if mf[i] > mf[i-1] and mf[i] > mf[i-2]:
                ax2.scatter(i, mf[i], color='darkgreen', s=50,
                           marker='o', zorder=5, edgecolors='black')
            # Check if MF is lower than both previous MFs (bearish signal)
            elif mf[i] < mf[i-1] and mf[i] < mf[i-2]:
                ax2.scatter(i, mf[i], color='darkred', s=50,
                           marker='o', zorder=5, edgecolors='black')

    ax2.set_ylabel('Momentum Factor', fontsize=10)
    ax2.set_title('Momentum Factor (Close - Previous Close)', fontsize=11)
    ax2.grid(True, alpha=0.3)

    # 3. Position and Distance from TBP
    ax3 = axes[2]

    # Calculate distance from close to TBP
    distance_to_tbp = np.zeros(len(momentum_df))
    for i in range(len(momentum_df)):
        if momentum_df['tbp'].iloc[i] > 0:
            distance_to_tbp[i] = momentum_df['close'].iloc[i] - momentum_df['tbp'].iloc[i]

    # Plot as filled area
    ax3.fill_between(x, 0, distance_to_tbp, where=(distance_to_tbp > 0),
                     alpha=0.5, color='green', label='Above TBP (Long)')
    ax3.fill_between(x, 0, distance_to_tbp, where=(distance_to_tbp < 0),
                     alpha=0.5, color='red', label='Below TBP (Short)')
    ax3.axhline(y=0, color='black', linestyle='-', linewidth=1)

    # Add position indicator line
    position_line = momentum_df['position'].values * 0.001  # Scale for visibility
    ax3.plot(x, position_line, 'blue', linewidth=2, alpha=0.5, label='Position')

    ax3.set_ylabel('Distance to TBP', fontsize=10)
    ax3.set_xlabel('Bar', fontsize=12)
    ax3.set_title('Distance from Close to Trend Balance Point', fontsize=11)
    ax3.legend(loc='upper left', fontsize=9)
    ax3.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

# Create the visualization
plot_momentum_tbp_analysis(df, momentum_df)

# Additional analysis
def analyze_momentum_system(momentum_df):
    """Analyze Momentum and TBP System performance"""

    print("\n" + "="*60)
    print("MOMENTUM AND TREND BALANCE POINT ANALYSIS")
    print("="*60)

    # Current values
    current_idx = -1
    print(f"\nCurrent Values:")
    print(f"  Close: {momentum_df['close'].iloc[current_idx]:.5f}")
    print(f"  Momentum Factor: {momentum_df['momentum_factor'].iloc[current_idx]:.5f}")
    print(f"  TBP: {momentum_df['tbp'].iloc[current_idx]:.5f}")
    print(f"  Position: {'LONG' if momentum_df['position'].iloc[current_idx] == 1 else 'SHORT' if momentum_df['position'].iloc[current_idx] == -1 else 'FLAT'}")

    if momentum_df['position'].iloc[current_idx] != 0:
        print(f"  Target: {momentum_df['target'].iloc[current_idx]:.5f}")
        print(f"  Stop: {momentum_df['stop'].iloc[current_idx]:.5f}")

    # Momentum statistics
    mf = momentum_df['momentum_factor'].values[1:]  # Skip first (0)
    print(f"\nMomentum Factor Statistics:")
    print(f"  Average: {np.mean(mf):.5f}")
    print(f"  Std Dev: {np.std(mf):.5f}")
    print(f"  Max: {np.max(mf):.5f}")
    print(f"  Min: {np.min(mf):.5f}")

    # Count positive vs negative momentum days
    positive_days = (mf > 0).sum()
    negative_days = (mf < 0).sum()
    zero_days = (mf == 0).sum()

    print(f"\nMomentum Distribution:")
    print(f"  Positive days: {positive_days} ({positive_days/len(mf)*100:.1f}%)")
    print(f"  Negative days: {negative_days} ({negative_days/len(mf)*100:.1f}%)")
    print(f"  Zero days: {zero_days} ({zero_days/len(mf)*100:.1f}%)")

    # Position changes
    position = momentum_df['position'].values
    position_changes = np.sum(np.diff(position) != 0)

    print(f"\nPosition Statistics:")
    long_bars = (position == 1).sum()
    short_bars = (position == -1).sum()
    flat_bars = (position == 0).sum()

    print(f"  Long bars: {long_bars} ({long_bars/len(position)*100:.1f}%)")
    print(f"  Short bars: {short_bars} ({short_bars/len(position)*100:.1f}%)")
    print(f"  Flat bars: {flat_bars} ({flat_bars/len(position)*100:.1f}%)")
    print(f"  Position changes: {position_changes}")

    # Momentum patterns
    print(f"\nMomentum Patterns (last 50 bars):")
    recent_mf = mf[-50:] if len(mf) > 50 else mf

    # Count acceleration/deceleration patterns
    accel_count = 0
    decel_count = 0

    for i in range(2, len(recent_mf)):
        if recent_mf[i] > recent_mf[i-1] > recent_mf[i-2]:
            accel_count += 1
        elif recent_mf[i] < recent_mf[i-1] < recent_mf[i-2]:
            decel_count += 1

    print(f"  Acceleration patterns: {accel_count}")
    print(f"  Deceleration patterns: {decel_count}")

    # Current momentum state
    if len(mf) >= 3:
        current_mf = mf[-1]
        prev_mf_1 = mf[-2]
        prev_mf_2 = mf[-3]

        print(f"\nCurrent Momentum State:")
        print(f"  Current MF: {current_mf:.5f}")
        print(f"  Previous MF: {prev_mf_1:.5f}")
        print(f"  2 bars ago MF: {prev_mf_2:.5f}")

        if current_mf > max(prev_mf_1, prev_mf_2):
            print("  → BULLISH: MF higher than both previous MFs")
        elif current_mf < min(prev_mf_1, prev_mf_2):
            print("  → BEARISH: MF lower than both previous MFs")
        else:
            print("  → NEUTRAL: MF between previous MFs")

# Analyze the system
analyze_momentum_system(momentum_df)

# Combined Momentum Analysis with Other Wilder Indicators
def plot_momentum_with_wilder_indicators(df, momentum_df, adx_df, vi_df):
    """
    Create comprehensive view combining Momentum/TBP with other Wilder indicators.
    """
    fig, axes = plt.subplots(5, 1, figsize=(18, 16),
                            height_ratios=[3, 1.5, 1, 1, 1])

    x = np.arange(len(df))

    # 1. Price Chart with TBP and Momentum Signals
    ax1 = axes[0]

    # Plot OHLC
    for i in range(len(df)):
        color = 'g' if df['Close'].iloc[i] >= df['Open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [df['Low'].iloc[i], df['High'].iloc[i]],
                 color=color, linewidth=1, alpha=0.7)
        rect = Rectangle((x[i]-0.3, min(df['Open'].iloc[i], df['Close'].iloc[i])),
                        0.6, abs(df['Close'].iloc[i] - df['Open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Plot TBP
    tbp_mask = momentum_df['tbp'] > 0
    ax1.plot(x[tbp_mask], momentum_df.loc[tbp_mask, 'tbp'],
             'blue', linewidth=2, label='TBP', alpha=0.8)

    # Add targets and stops for current position
    position = momentum_df['position'].values
    for i in range(len(momentum_df)):
        if position[i] != 0 and momentum_df['target'].iloc[i] > 0:
            if position[i] == 1:  # Long
                ax1.plot([i-0.5, i+0.5], [momentum_df['target'].iloc[i], momentum_df['target'].iloc[i]],
                        'g--', alpha=0.3, linewidth=1)
                ax1.plot([i-0.5, i+0.5], [momentum_df['stop'].iloc[i], momentum_df['stop'].iloc[i]],
                        'r--', alpha=0.3, linewidth=1)
            else:  # Short
                ax1.plot([i-0.5, i+0.5], [momentum_df['target'].iloc[i], momentum_df['target'].iloc[i]],
                        'r--', alpha=0.3, linewidth=1)
                ax1.plot([i-0.5, i+0.5], [momentum_df['stop'].iloc[i], momentum_df['stop'].iloc[i]],
                        'g--', alpha=0.3, linewidth=1)

    ax1.set_ylabel('Price', fontsize=12)
    ax1.set_title("Wilder's Complete Momentum Analysis System", fontsize=16)
    ax1.legend(loc='upper left', fontsize=10)
    ax1.grid(True, alpha=0.3)

    # 2. Momentum Factor with Acceleration
    ax2 = axes[1]

    mf = momentum_df['momentum_factor'].values
    colors = ['green' if val > 0 else 'red' for val in mf]
    ax2.bar(x, mf, color=colors, alpha=0.7, width=0.8)
    ax2.axhline(y=0, color='black', linewidth=1)

    # Calculate and plot momentum curve (smoothed)
    mf_ma = np.convolve(mf, np.ones(5)/5, mode='same')
    ax2.plot(x, mf_ma, 'black', linewidth=1.5, alpha=0.7, label='MF MA(5)')

    ax2.set_ylabel('Momentum Factor', fontsize=10)
    ax2.set_title('Momentum Factor with Moving Average', fontsize=11)
    ax2.legend(loc='upper left', fontsize=9)
    ax2.grid(True, alpha=0.3)

    # 3. ADX for Trend Strength
    ax3 = axes[2]

    adx = adx_df['adx'].values
    ax3.plot(x, adx, 'blue', linewidth=1.5, label='ADX(14)')
    ax3.fill_between(x, 0, adx, where=(adx < 20), alpha=0.2, color='gray')
    ax3.fill_between(x, 0, adx, where=(adx >= 20) & (adx < 40), alpha=0.2, color='orange')
    ax3.fill_between(x, 0, adx, where=(adx >= 40), alpha=0.2, color='red')

    ax3.axhline(y=20, color='gray', linestyle='--', alpha=0.5)
    ax3.axhline(y=40, color='gray', linestyle='--', alpha=0.5)

    ax3.set_ylabel('ADX', fontsize=10)
    ax3.set_title('Trend Strength (ADX)', fontsize=11)
    ax3.legend(loc='upper left', fontsize=9)
    ax3.grid(True, alpha=0.3)
    ax3.set_ylim(0, max(50, np.max(adx[adx > 0]) * 1.1) if len(adx[adx > 0]) > 0 else 50)

    # 4. Volatility (ATR)
    ax4 = axes[3]

    atr = vi_df['atr_14'].values
    ax4.plot(x, atr, 'purple', linewidth=1.5, label='ATR(14)')
    ax4.fill_between(x, 0, atr, alpha=0.3, color='purple')

    atr_mean = np.mean(atr[atr > 0])
    ax4.axhline(y=atr_mean, color='gray', linestyle=':', alpha=0.5,
                label=f'Avg: {atr_mean:.5f}')

    ax4.set_ylabel('ATR', fontsize=10)
    ax4.set_title('Volatility Index (ATR)', fontsize=11)
    ax4.legend(loc='upper left', fontsize=9)
    ax4.grid(True, alpha=0.3)

    # 5. Combined Signal Strength
    ax5 = axes[4]

    # Create a combined signal based on momentum and trend
    signal_strength = np.zeros(len(df))

    for i in range(2, len(df)):
        if i < len(momentum_df) and i < len(adx_df):
            # Momentum signal
            mf_signal = 0
            if mf[i] > mf[i-1] and mf[i] > mf[i-2]:
                mf_signal = 1
            elif mf[i] < mf[i-1] and mf[i] < mf[i-2]:
                mf_signal = -1

            # Trend strength weight
            trend_weight = min(adx[i] / 40, 1) if adx[i] > 0 else 0

            # Combined signal
            signal_strength[i] = mf_signal * trend_weight * position[i]

    # Plot signal strength
    colors = ['green' if val > 0 else 'red' if val < 0 else 'gray' for val in signal_strength]
    ax5.bar(x, signal_strength, color=colors, alpha=0.7, width=0.8)
    ax5.axhline(y=0, color='black', linewidth=1)

    ax5.set_ylabel('Signal Strength', fontsize=10)
    ax5.set_xlabel('Bar', fontsize=12)
    ax5.set_title('Combined Momentum-Trend Signal Strength', fontsize=11)
    ax5.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

    # Print integrated analysis
    print("\n" + "="*60)
    print("INTEGRATED MOMENTUM-WILDER SYSTEM ANALYSIS")
    print("="*60)

    current_idx = -1
    print(f"\nCurrent Market State:")
    print(f"  Price: {df['Close'].iloc[current_idx]:.5f}")
    print(f"  TBP: {momentum_df['tbp'].iloc[current_idx]:.5f}")
    print(f"  Position: {'LONG' if position[current_idx] == 1 else 'SHORT' if position[current_idx] == -1 else 'FLAT'}")

    print(f"\nMomentum Analysis:")
    print(f"  Momentum Factor: {mf[current_idx]:.5f}")
    if len(mf) >= 3:
        if mf[-1] > max(mf[-2], mf[-3]):
            print("  → Momentum: BULLISH (accelerating)")
        elif mf[-1] < min(mf[-2], mf[-3]):
            print("  → Momentum: BEARISH (decelerating)")
        else:
            print("  → Momentum: NEUTRAL")

    print(f"\nTrend Analysis:")
    if adx[current_idx] > 0:
        print(f"  ADX: {adx[current_idx]:.2f}")
        if adx[current_idx] > 40:
            print("  → Trend: STRONG")
        elif adx[current_idx] > 20:
            print("  → Trend: MODERATE")
        else:
            print("  → Trend: WEAK/ABSENT")

    print(f"\nVolatility Analysis:")
    print(f"  Current ATR: {atr[current_idx]:.5f}")
    if atr[current_idx] > atr_mean * 1.5:
        print("  → Volatility: HIGH")
    elif atr[current_idx] < atr_mean * 0.5:
        print("  → Volatility: LOW")
    else:
        print("  → Volatility: NORMAL")

    print(f"\nTrading Recommendations:")
    if adx[current_idx] > 25 and abs(mf[current_idx]) > np.std(mf):
        print("  ✓ Strong trend with momentum - favor trend-following")
        if position[current_idx] == 1:
            print("  → Maintain LONG bias, use TBP as trailing stop")
        elif position[current_idx] == -1:
            print("  → Maintain SHORT bias, use TBP as trailing stop")
    elif adx[current_idx] < 20:
        print("  ✗ Weak trend - consider range-trading or waiting")
        print("  → TBP system may generate whipsaws")
    else:
        print("  → Moderate conditions - trade with caution")

# Create the combined analysis
plot_momentum_with_wilder_indicators(df, momentum_df, adx_df, vi_df)

# Final Summary
print("\n" + "="*70)
print("WILDER'S MOMENTUM AND TREND BALANCE POINT SYSTEM - COMPLETE")
print("="*70)
print("\nThe Momentum Concept and TBP System provides:")
print("1. Clear entry/exit signals based on momentum acceleration")
print("2. Dynamic support/resistance levels (TBP)")
print("3. Objective position management with targets and stops")
print("4. Integration with other Wilder indicators for confirmation")
print("\nBest used in trending markets identified by ADX > 25")
print("="*70)

# Reaction Trend System Implementation - Welles Wilder's Original Method
def calculate_reaction_trend_system(df):
    """
    Calculate Reaction Trend System according to Welles Wilder's method.

    The system operates in two modes:
    1. REACTION MODE (anti-trend) - normal mode using B-O-S-O pattern
    2. TREND MODE - when price breaks through HBOP or LBOP

    Key calculations:
    - X = (H + L + C) / 3
    - B₁ = 2X - H (Buy point)
    - S₁ = 2X - L (Sell point)
    - HBOP = 2X - 2L + H (High Breakout Point)
    - LBOP = 2X - 2H + L (Low Breakout Point)

    Returns:
    - Dictionary with all system components
    """
    n = len(df)

    # Initialize arrays
    x_values = np.zeros(n)
    b1_values = np.zeros(n)
    s1_values = np.zeros(n)
    hbop_values = np.zeros(n)
    lbop_values = np.zeros(n)

    # Day sequence: B-O-S-O pattern
    day_sequence = ['B', 'O', 'S', 'O']
    day_type = []

    # Position tracking
    position = np.zeros(n)  # 1 for long, -1 for short, 0 for flat
    mode = ['REACTION'] * n  # REACTION or TREND
    trailing_stop = np.zeros(n)

    # Calculate X and price action points for each day
    for i in range(n):
        # Calculate X = (H + L + C) / 3
        x_values[i] = (df['High'].iloc[i] + df['Low'].iloc[i] + df['Close'].iloc[i]) / 3

        # Calculate price action points for next day
        if i < n - 1:
            # B₁ = 2X - H
            b1_values[i + 1] = 2 * x_values[i] - df['High'].iloc[i]

            # S₁ = 2X - L
            s1_values[i + 1] = 2 * x_values[i] - df['Low'].iloc[i]

            # HBOP = 2X - 2L + H
            hbop_values[i + 1] = 2 * x_values[i] - 2 * df['Low'].iloc[i] + df['High'].iloc[i]

            # LBOP = 2X - 2H + L
            lbop_values[i + 1] = 2 * x_values[i] - 2 * df['High'].iloc[i] + df['Low'].iloc[i]

    # Determine day type for each bar
    for i in range(n):
        day_type.append(day_sequence[i % 4])

    # Trading logic
    for i in range(1, n):
        current_day = day_type[i]

        # Check for breakout to TREND mode
        if df['High'].iloc[i] >= hbop_values[i] and hbop_values[i] > 0:
            mode[i] = 'TREND'
            position[i] = 1  # Go long at HBOP
            # Trailing stop is the lower of the two previous lows
            if i >= 2:
                trailing_stop[i] = min(df['Low'].iloc[i-1], df['Low'].iloc[i-2])
            else:
                trailing_stop[i] = df['Low'].iloc[i-1]

        elif df['Low'].iloc[i] <= lbop_values[i] and lbop_values[i] > 0:
            mode[i] = 'TREND'
            position[i] = -1  # Go short at LBOP
            # Trailing stop is the higher of the two previous highs
            if i >= 2:
                trailing_stop[i] = max(df['High'].iloc[i-1], df['High'].iloc[i-2])
            else:
                trailing_stop[i] = df['High'].iloc[i-1]

        # TREND mode logic
        elif mode[i-1] == 'TREND':
            mode[i] = 'TREND'

            if position[i-1] == 1:  # Long position
                # Update trailing stop
                if i >= 2:
                    trailing_stop[i] = min(df['Low'].iloc[i-1], df['Low'].iloc[i-2])
                else:
                    trailing_stop[i] = df['Low'].iloc[i-1]

                # Check if stopped out
                if df['Low'].iloc[i] <= trailing_stop[i]:
                    position[i] = 0  # Exit, return to REACTION mode
                    mode[i] = 'REACTION'
                else:
                    position[i] = 1  # Stay long

            elif position[i-1] == -1:  # Short position
                # Update trailing stop
                if i >= 2:
                    trailing_stop[i] = max(df['High'].iloc[i-1], df['High'].iloc[i-2])
                else:
                    trailing_stop[i] = df['High'].iloc[i-1]

                # Check if stopped out
                if df['High'].iloc[i] >= trailing_stop[i]:
                    position[i] = 0  # Exit, return to REACTION mode
                    mode[i] = 'REACTION'
                else:
                    position[i] = -1  # Stay short

        # REACTION mode logic
        else:
            mode[i] = 'REACTION'

            if current_day == 'B':  # Buy day
                if df['Low'].iloc[i] <= b1_values[i] and b1_values[i] > 0:
                    position[i] = 1  # Buy at B₁
                else:
                    position[i] = position[i-1]  # Hold previous position

            elif current_day == 'S':  # Sell day
                if df['High'].iloc[i] >= s1_values[i] and s1_values[i] > 0:
                    position[i] = -1  # Sell at S₁
                else:
                    position[i] = position[i-1]  # Hold previous position

            else:  # 'O' day - Off day
                # Exit on close if conditions are met
                if position[i-1] == 1 and current_day == 'S':
                    # From long position on 'S' day, exit if S₁ not touched
                    if df['High'].iloc[i] < s1_values[i]:
                        position[i] = 0  # Exit on close
                    else:
                        position[i] = position[i-1]
                elif position[i-1] == -1 and current_day == 'B':
                    # From short position on 'B' day, exit if B₁ not touched
                    if df['Low'].iloc[i] > b1_values[i]:
                        position[i] = 0  # Exit on close
                    else:
                        position[i] = position[i-1]
                else:
                    position[i] = position[i-1]  # Hold position

    return {
        'x': x_values,
        'b1': b1_values,
        's1': s1_values,
        'hbop': hbop_values,
        'lbop': lbop_values,
        'day_type': day_type,
        'position': position,
        'mode': mode,
        'trailing_stop': trailing_stop
    }

# Calculate Reaction Trend System
reaction_data = calculate_reaction_trend_system(df)

# Create Reaction Trend DataFrame
reaction_trend_df = pd.DataFrame({
    'date': df.index,
    'open': df['Open'],
    'high': df['High'],
    'low': df['Low'],
    'close': df['Close'],
    'x': reaction_data['x'],
    'b1': reaction_data['b1'],
    's1': reaction_data['s1'],
    'hbop': reaction_data['hbop'],
    'lbop': reaction_data['lbop'],
    'day_type': reaction_data['day_type'],
    'position': reaction_data['position'],
    'mode': reaction_data['mode'],
    'trailing_stop': reaction_data['trailing_stop']
})

# Display sample data
print("Reaction Trend System Analysis Sample:")
print("\nFirst 20 rows:")
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
print(reaction_trend_df[['date', 'close', 'x', 'b1', 's1', 'hbop', 'lbop', 'day_type', 'position', 'mode']].head(20))

print("\nLast 10 rows:")
print(reaction_trend_df[['date', 'close', 'day_type', 'position', 'mode']].tail(10))

# Visualize Reaction Trend System
def plot_reaction_trend_system(df, reaction_trend_df):
    """
    Create comprehensive visualization of Reaction Trend System.

    Shows:
    1. Price chart with B₁/S₁ levels and breakout points (HBOP/LBOP)
    2. Mode indicator (REACTION vs TREND)
    3. Position and day sequence
    """
    fig, axes = plt.subplots(3, 1, figsize=(16, 12), height_ratios=[3, 1, 1])

    x = np.arange(len(df))

    # 1. Price Chart with Reaction Trend Levels
    ax1 = axes[0]

    # Plot OHLC candlesticks
    for i in range(len(df)):
        color = 'g' if df['Close'].iloc[i] >= df['Open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [df['Low'].iloc[i], df['High'].iloc[i]],
                 color=color, linewidth=1, alpha=0.7)
        rect = Rectangle((x[i]-0.3, min(df['Open'].iloc[i], df['Close'].iloc[i])),
                        0.6, abs(df['Close'].iloc[i] - df['Open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Plot B₁ and S₁ levels
    b1_mask = reaction_trend_df['b1'] > 0
    s1_mask = reaction_trend_df['s1'] > 0

    # Draw B₁ levels (green dots for buy days)
    for i in range(len(reaction_trend_df)):
        if b1_mask[i] and reaction_trend_df['day_type'].iloc[i] == 'B':
            ax1.plot([i-0.4, i+0.4],
                     [reaction_trend_df['b1'].iloc[i], reaction_trend_df['b1'].iloc[i]],
                     'g-', linewidth=2, alpha=0.6)
            ax1.scatter(i, reaction_trend_df['b1'].iloc[i],
                       color='green', s=20, marker='_', zorder=5)

    # Draw S₁ levels (red dots for sell days)
    for i in range(len(reaction_trend_df)):
        if s1_mask[i] and reaction_trend_df['day_type'].iloc[i] == 'S':
            ax1.plot([i-0.4, i+0.4],
                     [reaction_trend_df['s1'].iloc[i], reaction_trend_df['s1'].iloc[i]],
                     'r-', linewidth=2, alpha=0.6)
            ax1.scatter(i, reaction_trend_df['s1'].iloc[i],
                       color='red', s=20, marker='_', zorder=5)

    # Plot HBOP and LBOP levels (thinner lines)
    hbop_mask = reaction_trend_df['hbop'] > 0
    lbop_mask = reaction_trend_df['lbop'] > 0

    for i in range(len(reaction_trend_df)):
        if hbop_mask[i]:
            ax1.plot([i-0.4, i+0.4],
                     [reaction_trend_df['hbop'].iloc[i], reaction_trend_df['hbop'].iloc[i]],
                     'b--', linewidth=1, alpha=0.4)
        if lbop_mask[i]:
            ax1.plot([i-0.4, i+0.4],
                     [reaction_trend_df['lbop'].iloc[i], reaction_trend_df['lbop'].iloc[i]],
                     'b--', linewidth=1, alpha=0.4)

    # Shade background based on position
    position = reaction_trend_df['position'].values
    for i in range(1, len(reaction_trend_df)):
        if position[i] == 1 and position[i-1] == 1:  # Long
            ax1.axvspan(i-1, i, alpha=0.05, color='green', zorder=0)
        elif position[i] == -1 and position[i-1] == -1:  # Short
            ax1.axvspan(i-1, i, alpha=0.05, color='red', zorder=0)

    # Mark mode changes (REACTION to TREND)
    mode = reaction_trend_df['mode'].values
    for i in range(1, len(reaction_trend_df)):
        if mode[i] == 'TREND' and mode[i-1] == 'REACTION':
            ax1.axvline(x=i, color='blue', alpha=0.3, linestyle=':', linewidth=2)
            if position[i] == 1:
                ax1.annotate('TREND↑', xy=(i, df['High'].iloc[i]),
                           xytext=(i, df['High'].iloc[i] * 1.01),
                           fontsize=8, color='blue', ha='center', weight='bold')
            else:
                ax1.annotate('TREND↓', xy=(i, df['Low'].iloc[i]),
                           xytext=(i, df['Low'].iloc[i] * 0.99),
                           fontsize=8, color='blue', ha='center', weight='bold')

    # Plot trailing stops in TREND mode
    for i in range(len(reaction_trend_df)):
        if mode[i] == 'TREND' and reaction_trend_df['trailing_stop'].iloc[i] > 0:
            color = 'darkgreen' if position[i] == 1 else 'darkred'
            ax1.scatter(i, reaction_trend_df['trailing_stop'].iloc[i],
                       color=color, s=15, marker='x', alpha=0.7)

    ax1.set_ylabel('Price', fontsize=12)
    ax1.set_title("Welles Wilder's Reaction Trend System", fontsize=14)
    ax1.grid(True, alpha=0.3)

    # Add legend
    from matplotlib.lines import Line2D
    legend_elements = [
        Line2D([0], [0], color='green', linewidth=2, label='B₁ (Buy Level)'),
        Line2D([0], [0], color='red', linewidth=2, label='S₁ (Sell Level)'),
        Line2D([0], [0], color='blue', linewidth=1, linestyle='--', label='HBOP/LBOP'),
        Line2D([0], [0], marker='x', color='w', markerfacecolor='darkgreen',
               markersize=8, label='Trailing Stop (L)'),
        Line2D([0], [0], marker='x', color='w', markerfacecolor='darkred',
               markersize=8, label='Trailing Stop (S)')
    ]
    ax1.legend(handles=legend_elements, loc='upper left', fontsize=9)

    # 2. Mode Indicator
    ax2 = axes[1]

    # Create mode numeric values for plotting
    mode_numeric = np.zeros(len(reaction_trend_df))
    for i in range(len(reaction_trend_df)):
        if mode[i] == 'TREND':
            mode_numeric[i] = 1
        else:
            mode_numeric[i] = 0

    # Plot mode as filled areas
    ax2.fill_between(x, 0, mode_numeric, where=(mode_numeric == 1),
                     alpha=0.5, color='blue', label='TREND Mode', step='mid')
    ax2.fill_between(x, 0, mode_numeric, where=(mode_numeric == 0),
                     alpha=0.5, color='gray', label='REACTION Mode', step='mid')

    # Add mode transitions
    for i in range(1, len(mode_numeric)):
        if mode_numeric[i] != mode_numeric[i-1]:
            ax2.axvline(x=i, color='black', alpha=0.5, linestyle='--', linewidth=1)

    ax2.set_ylabel('Mode', fontsize=10)
    ax2.set_ylim(-0.1, 1.1)
    ax2.set_yticks([0, 1])
    ax2.set_yticklabels(['REACTION', 'TREND'])
    ax2.set_title('System Mode (REACTION vs TREND)', fontsize=11)
    ax2.legend(loc='upper right', fontsize=9)
    ax2.grid(True, alpha=0.3)

    # 3. Day Sequence and Position
    ax3 = axes[2]

    # Plot position
    ax3.plot(x, position, 'black', linewidth=2, alpha=0.7, label='Position')
    ax3.fill_between(x, 0, position, where=(position > 0),
                     alpha=0.3, color='green', label='Long')
    ax3.fill_between(x, 0, position, where=(position < 0),
                     alpha=0.3, color='red', label='Short')

    # Add day type labels
    day_colors = {'B': 'green', 'O': 'gray', 'S': 'red'}
    for i in range(0, len(reaction_trend_df), 20):  # Show every 20th day to avoid crowding
        day = reaction_trend_df['day_type'].iloc[i]
        ax3.text(i, -1.5, day, fontsize=8, ha='center',
                color=day_colors.get(day, 'black'), weight='bold')

    ax3.axhline(y=0, color='black', linestyle='-', linewidth=1)
    ax3.set_ylabel('Position', fontsize=10)
    ax3.set_xlabel('Bar', fontsize=12)
    ax3.set_ylim(-2, 2)
    ax3.set_yticks([-1, 0, 1])
    ax3.set_yticklabels(['Short', 'Flat', 'Long'])
    ax3.set_title('Position and Day Sequence (B-O-S-O)', fontsize=11)
    ax3.legend(loc='upper left', fontsize=9)
    ax3.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

# Create the visualization
plot_reaction_trend_system(df, reaction_trend_df)

# Additional analysis
def analyze_reaction_trend_system(reaction_trend_df):
    """Analyze Reaction Trend System performance and statistics"""

    print("\n" + "="*60)
    print("REACTION TREND SYSTEM ANALYSIS")
    print("="*60)

    # Current values
    current_idx = -1
    print(f"\nCurrent Values:")
    print(f"  Close: {reaction_trend_df['close'].iloc[current_idx]:.5f}")
    print(f"  X: {reaction_trend_df['x'].iloc[current_idx]:.5f}")
    print(f"  Day Type: {reaction_trend_df['day_type'].iloc[current_idx]}")
    print(f"  Mode: {reaction_trend_df['mode'].iloc[current_idx]}")
    print(f"  Position: {'LONG' if reaction_trend_df['position'].iloc[current_idx] == 1 else 'SHORT' if reaction_trend_df['position'].iloc[current_idx] == -1 else 'FLAT'}")

    # Price action points for next day (if available)
    print(f"\nNext Day Price Action Points:")
    print(f"  B₁: {reaction_trend_df['b1'].iloc[current_idx]:.5f} (Buy point)")
    print(f"  S₁: {reaction_trend_df['s1'].iloc[current_idx]:.5f} (Sell point)")
    print(f"  HBOP: {reaction_trend_df['hbop'].iloc[current_idx]:.5f} (High breakout)")
    print(f"  LBOP: {reaction_trend_df['lbop'].iloc[current_idx]:.5f} (Low breakout)")

    if reaction_trend_df['mode'].iloc[current_idx] == 'TREND':
        print(f"  Trailing Stop: {reaction_trend_df['trailing_stop'].iloc[current_idx]:.5f}")

    # Mode statistics
    mode_counts = pd.Series(reaction_trend_df['mode'].values).value_counts()
    print(f"\nMode Distribution:")
    for mode, count in mode_counts.items():
        pct = (count / len(reaction_trend_df)) * 100
        print(f"  {mode}: {count} bars ({pct:.1f}%)")

    # Count mode transitions
    mode_changes = 0
    trend_entries = 0
    for i in range(1, len(reaction_trend_df)):
        if reaction_trend_df['mode'].iloc[i] != reaction_trend_df['mode'].iloc[i-1]:
            mode_changes += 1
            if reaction_trend_df['mode'].iloc[i] == 'TREND':
                trend_entries += 1

    print(f"\nMode Transitions:")
    print(f"  Total mode changes: {mode_changes}")
    print(f"  TREND mode entries: {trend_entries}")

    # Position statistics
    position = reaction_trend_df['position'].values
    long_bars = (position == 1).sum()
    short_bars = (position == -1).sum()
    flat_bars = (position == 0).sum()

    print(f"\nPosition Statistics:")
    print(f"  Long bars: {long_bars} ({long_bars/len(position)*100:.1f}%)")
    print(f"  Short bars: {short_bars} ({short_bars/len(position)*100:.1f}%)")
    print(f"  Flat bars: {flat_bars} ({flat_bars/len(position)*100:.1f}%)")

    # Position changes
    position_changes = np.sum(np.diff(position) != 0)
    print(f"  Position changes: {position_changes}")

    # Calculate average bars per position
    if position_changes > 0:
        avg_bars_per_position = len(position) / position_changes
        print(f"  Average bars per position: {avg_bars_per_position:.1f}")

    # Day sequence analysis
    print(f"\nDay Sequence Pattern:")
    day_counts = pd.Series(reaction_trend_df['day_type'].values).value_counts()
    for day in ['B', 'O', 'S']:
        if day in day_counts:
            print(f"  {day} days: {day_counts[day]} ({day_counts[day]/len(reaction_trend_df)*100:.1f}%)")

    # Price action point spreads
    print(f"\nPrice Action Point Spreads (current):")
    current_close = reaction_trend_df['close'].iloc[current_idx]
    b1_spread = (current_close - reaction_trend_df['b1'].iloc[current_idx]) / current_close * 100
    s1_spread = (reaction_trend_df['s1'].iloc[current_idx] - current_close) / current_close * 100
    hbop_spread = (reaction_trend_df['hbop'].iloc[current_idx] - current_close) / current_close * 100
    lbop_spread = (current_close - reaction_trend_df['lbop'].iloc[current_idx]) / current_close * 100

    print(f"  B₁ below close: {b1_spread:.2f}%")
    print(f"  S₁ above close: {s1_spread:.2f}%")
    print(f"  HBOP above close: {hbop_spread:.2f}%")
    print(f"  LBOP below close: {lbop_spread:.2f}%")

    # Trading recommendations
    print(f"\nTrading Recommendations:")
    if reaction_trend_df['mode'].iloc[current_idx] == 'TREND':
        print("  → System is in TREND mode - follow trailing stops")
        if reaction_trend_df['position'].iloc[current_idx] == 1:
            print(f"  → LONG position, stop at {reaction_trend_df['trailing_stop'].iloc[current_idx]:.5f}")
        elif reaction_trend_df['position'].iloc[current_idx] == -1:
            print(f"  → SHORT position, stop at {reaction_trend_df['trailing_stop'].iloc[current_idx]:.5f}")
    else:
        print("  → System is in REACTION mode - watch for B₁/S₁ levels")
        next_day = reaction_trend_df['day_type'].iloc[current_idx]
        if next_day == 'B':
            print(f"  → Tomorrow is a BUY day - watch B₁ at {reaction_trend_df['b1'].iloc[current_idx]:.5f}")
        elif next_day == 'S':
            print(f"  → Tomorrow is a SELL day - watch S₁ at {reaction_trend_df['s1'].iloc[current_idx]:.5f}")
        else:
            print("  → Tomorrow is an OFF day - possible exit on close")

# Analyze the system
analyze_reaction_trend_system(reaction_trend_df)

# Integrated Reaction Trend System with All Wilder Indicators
def plot_complete_wilder_reaction_trend_system(df, reaction_trend_df, adx_df, vi_df, additional_asi_analysis):
    """
    Create the complete integrated visualization combining Reaction Trend System
    with all other Wilder indicators for comprehensive analysis.
    """
    fig, axes = plt.subplots(6, 1, figsize=(18, 20),
                            height_ratios=[3, 1.5, 1.5, 1, 1, 1])

    x = np.arange(len(df))

    # 1. Price Chart with Reaction Trend Levels and Other Systems
    ax1 = axes[0]

    # Plot OHLC candlesticks
    for i in range(len(df)):
        color = 'g' if df['Close'].iloc[i] >= df['Open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]], [df['Low'].iloc[i], df['High'].iloc[i]],
                 color=color, linewidth=1, alpha=0.7)
        rect = Rectangle((x[i]-0.3, min(df['Open'].iloc[i], df['Close'].iloc[i])),
                        0.6, abs(df['Close'].iloc[i] - df['Open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    # Plot Reaction Trend B₁/S₁ levels
    for i in range(len(reaction_trend_df)):
        if reaction_trend_df['day_type'].iloc[i] == 'B' and reaction_trend_df['b1'].iloc[i] > 0:
            ax1.plot([i-0.4, i+0.4],
                     [reaction_trend_df['b1'].iloc[i], reaction_trend_df['b1'].iloc[i]],
                     'g-', linewidth=2, alpha=0.6)
        elif reaction_trend_df['day_type'].iloc[i] == 'S' and reaction_trend_df['s1'].iloc[i] > 0:
            ax1.plot([i-0.4, i+0.4],
                     [reaction_trend_df['s1'].iloc[i], reaction_trend_df['s1'].iloc[i]],
                     'r-', linewidth=2, alpha=0.6)

    # Add Parabolic SAR (smaller dots)
    psar = additional_asi_analysis['psar'].values
    psar_position = additional_asi_analysis['psar_position'].values
    psar_long = psar_position == 1
    psar_short = psar_position == -1

    ax1.scatter(x[psar_long], psar[psar_long], color='lightgreen', s=5,
                marker='o', alpha=0.5, zorder=6)
    ax1.scatter(x[psar_short], psar[psar_short], color='lightcoral', s=5,
                marker='o', alpha=0.5, zorder=6)

    # Mark Reaction Trend mode changes
    mode = reaction_trend_df['mode'].values
    for i in range(1, len(reaction_trend_df)):
        if mode[i] == 'TREND' and mode[i-1] == 'REACTION':
            ax1.axvline(x=i, color='blue', alpha=0.2, linestyle=':', linewidth=2)

    ax1.set_ylabel('Price', fontsize=12)
    ax1.set_title("Wilder's Complete Technical Trading System with Reaction Trend", fontsize=16, pad=20)
    ax1.grid(True, alpha=0.3)

    # 2. Reaction Trend Mode and Position
    ax2 = axes[1]

    # Left y-axis: Mode
    mode_numeric = np.array([1 if m == 'TREND' else 0 for m in mode])
    ax2.fill_between(x, 0, mode_numeric, where=(mode_numeric == 1),
                     alpha=0.3, color='blue', label='TREND', step='mid')
    ax2.fill_between(x, 0, mode_numeric, where=(mode_numeric == 0),
                     alpha=0.3, color='gray', label='REACTION', step='mid')

    # Right y-axis: Position
    ax2_twin = ax2.twinx()
    position = reaction_trend_df['position'].values
    ax2_twin.plot(x, position, 'black', linewidth=2, alpha=0.7, label='Position')
    ax2_twin.set_ylabel('Position', fontsize=10)
    ax2_twin.set_ylim(-1.5, 1.5)
    ax2_twin.set_yticks([-1, 0, 1])
    ax2_twin.set_yticklabels(['Short', 'Flat', 'Long'])

    ax2.set_ylabel('Mode', fontsize=10)
    ax2.set_ylim(-0.1, 1.1)
    ax2.set_yticks([0, 1])
    ax2.set_yticklabels(['REACTION', 'TREND'])
    ax2.set_title('Reaction Trend System Mode & Position', fontsize=11)
    ax2.legend(loc='upper left', fontsize=8)
    ax2_twin.legend(loc='upper right', fontsize=8)
    ax2.grid(True, alpha=0.3)

    # 3. Directional Movement Index
    ax3 = axes[2]

    plus_di = adx_df['plus_di'].values
    minus_di = adx_df['minus_di'].values
    adx = adx_df['adx'].values

    ax3.plot(x, plus_di, 'green', linewidth=1, label='+DI', alpha=0.8)
    ax3.plot(x, minus_di, 'red', linewidth=1, label='-DI', alpha=0.8)
    ax3.plot(x, adx, 'blue', linewidth=1.5, label='ADX', alpha=0.9)

    ax3.axhline(y=25, color='gray', linestyle='--', alpha=0.5)
    ax3.fill_between(x, 0, adx, where=(adx > 25), alpha=0.1, color='blue')

    ax3.set_ylabel('DMI', fontsize=10)
    ax3.set_title('Directional Movement Index', fontsize=11)
    ax3.legend(loc='upper left', fontsize=8, ncol=3)
    ax3.grid(True, alpha=0.3)
    ax3.set_ylim(0, max(50, np.max(adx[adx > 0]) * 1.1) if len(adx[adx > 0]) > 0 else 50)

    # 4. Volatility Index
    ax4 = axes[3]

    atr = vi_df['atr_14'].values
    ax4.plot(x, atr, 'purple', linewidth=1.5, label='ATR(14)')
    ax4.fill_between(x, 0, atr, alpha=0.3, color='purple')

    atr_mean = np.mean(atr[atr > 0])
    ax4.axhline(y=atr_mean, color='gray', linestyle=':', alpha=0.5,
                label=f'Avg: {atr_mean:.5f}')

    ax4.set_ylabel('ATR', fontsize=10)
    ax4.set_title('Volatility Index', fontsize=11)
    ax4.legend(loc='upper left', fontsize=8)
    ax4.grid(True, alpha=0.3)

    # 5. RSI
    ax5 = axes[4]

    price_rsi = additional_asi_analysis['price_rsi'].values
    ax5.plot(x, price_rsi, 'blue', linewidth=1.2)
    ax5.axhline(y=70, color='red', linestyle='--', alpha=0.5)
    ax5.axhline(y=30, color='green', linestyle='--', alpha=0.5)
    ax5.axhline(y=50, color='gray', linestyle='-', alpha=0.3)
    ax5.fill_between(x, 70, 100, alpha=0.1, color='red')
    ax5.fill_between(x, 0, 30, alpha=0.1, color='green')

    ax5.set_ylabel('RSI', fontsize=10)
    ax5.set_ylim(0, 100)
    ax5.set_title('Relative Strength Index', fontsize=11)
    ax5.grid(True, alpha=0.3)

    # 6. Combined Signal Strength
    ax6 = axes[5]

    # Create combined signal based on all systems
    combined_signal = np.zeros(len(df))

    for i in range(len(df)):
        signal_count = 0
        total_weight = 0

        # Reaction Trend signal
        if i < len(reaction_trend_df):
            if reaction_trend_df['position'].iloc[i] == 1:
                signal_count += 1
                if reaction_trend_df['mode'].iloc[i] == 'TREND':
                    total_weight += 2  # Double weight in TREND mode
                else:
                    total_weight += 1
            elif reaction_trend_df['position'].iloc[i] == -1:
                signal_count -= 1
                if reaction_trend_df['mode'].iloc[i] == 'TREND':
                    total_weight += 2
                else:
                    total_weight += 1

        # DMI signal
        if i < len(adx_df) and adx[i] > 25:
            if plus_di[i] > minus_di[i]:
                signal_count += 1
                total_weight += 1.5
            else:
                signal_count -= 1
                total_weight += 1.5

        # RSI signal
        if i < len(price_rsi) and not np.isnan(price_rsi[i]):
            if price_rsi[i] < 30:
                signal_count += 0.5
                total_weight += 0.5
            elif price_rsi[i] > 70:
                signal_count -= 0.5
                total_weight += 0.5

        # Normalize combined signal
        if total_weight > 0:
            combined_signal[i] = signal_count / total_weight

    # Plot combined signal
    colors = ['green' if val > 0 else 'red' if val < 0 else 'gray' for val in combined_signal]
    ax6.bar(x, combined_signal, color=colors, alpha=0.7, width=0.8)
    ax6.axhline(y=0, color='black', linewidth=1)

    ax6.set_ylabel('Signal', fontsize=10)
    ax6.set_xlabel('Bar', fontsize=12)
    ax6.set_title('Combined System Signal Strength', fontsize=11)
    ax6.set_ylim(-1.2, 1.2)
    ax6.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

    # Print comprehensive analysis
    print("\n" + "="*70)
    print("COMPLETE WILDER SYSTEM WITH REACTION TREND - ANALYSIS")
    print("="*70)

    current_idx = -1
    print(f"\nCurrent Market State:")
    print(f"  Price: {df['Close'].iloc[current_idx]:.5f}")

    print(f"\n1. REACTION TREND SYSTEM:")
    print(f"   Mode: {reaction_trend_df['mode'].iloc[current_idx]}")
    print(f"   Position: {'LONG' if reaction_trend_df['position'].iloc[current_idx] == 1 else 'SHORT' if reaction_trend_df['position'].iloc[current_idx] == -1 else 'FLAT'}")
    print(f"   Day Type: {reaction_trend_df['day_type'].iloc[current_idx]}")
    print(f"   B₁: {reaction_trend_df['b1'].iloc[current_idx]:.5f}")
    print(f"   S₁: {reaction_trend_df['s1'].iloc[current_idx]:.5f}")

    print(f"\n2. DIRECTIONAL MOVEMENT:")
    if current_idx < len(adx_df):
        print(f"   +DI: {plus_di[current_idx]:.2f}")
        print(f"   -DI: {minus_di[current_idx]:.2f}")
        print(f"   ADX: {adx[current_idx]:.2f}")
        print(f"   Trend: {'STRONG' if adx[current_idx] > 40 else 'MODERATE' if adx[current_idx] > 25 else 'WEAK'}")

    print(f"\n3. VOLATILITY:")
    if current_idx < len(vi_df):
        print(f"   ATR(14): {atr[current_idx]:.5f}")
        vol_level = 'HIGH' if atr[current_idx] > atr_mean * 1.5 else 'LOW' if atr[current_idx] < atr_mean * 0.5 else 'NORMAL'
        print(f"   Level: {vol_level}")

    print(f"\n4. MOMENTUM:")
    if current_idx < len(price_rsi) and not np.isnan(price_rsi[current_idx]):
        print(f"   RSI: {price_rsi[current_idx]:.2f}")
        if price_rsi[current_idx] > 70:
            print("   → Overbought")
        elif price_rsi[current_idx] < 30:
            print("   → Oversold")
        else:
            print("   → Neutral")

    print(f"\n5. SYSTEM ALIGNMENT:")
    # Count bullish/bearish signals
    bullish_count = 0
    bearish_count = 0

    if reaction_trend_df['position'].iloc[current_idx] == 1:
        bullish_count += 2 if reaction_trend_df['mode'].iloc[current_idx] == 'TREND' else 1
    elif reaction_trend_df['position'].iloc[current_idx] == -1:
        bearish_count += 2 if reaction_trend_df['mode'].iloc[current_idx] == 'TREND' else 1

    if current_idx < len(adx_df) and adx[current_idx] > 25:
        if plus_di[current_idx] > minus_di[current_idx]:
            bullish_count += 1
        else:
            bearish_count += 1

    print(f"   Bullish signals: {bullish_count}")
    print(f"   Bearish signals: {bearish_count}")

    if bullish_count > bearish_count + 1:
        print("   → STRONG BULLISH CONSENSUS")
    elif bullish_count > bearish_count:
        print("   → MODERATE BULLISH BIAS")
    elif bearish_count > bullish_count + 1:
        print("   → STRONG BEARISH CONSENSUS")
    elif bearish_count > bullish_count:
        print("   → MODERATE BEARISH BIAS")
    else:
        print("   → NEUTRAL/MIXED SIGNALS")

    print(f"\n6. TRADING RECOMMENDATIONS:")

    # Reaction Trend specific recommendations
    if reaction_trend_df['mode'].iloc[current_idx] == 'TREND':
        print("   ✓ Reaction Trend in TREND mode - strong directional signal")
        if adx[current_idx] > 25:
            print("   ✓ ADX confirms trending market - ideal conditions")
        else:
            print("   ⚠ ADX shows weak trend - be cautious")
    else:
        print("   → Reaction Trend in REACTION mode - range trading")
        if adx[current_idx] < 20:
            print("   ✓ ADX confirms non-trending market - good for reaction trading")
        else:
            print("   ⚠ ADX shows trending market - watch for breakouts")

    # Volatility considerations
    if atr[current_idx] > atr_mean * 1.5:
        print("   ⚠ High volatility - use wider stops")
    elif atr[current_idx] < atr_mean * 0.5:
        print("   ⚠ Low volatility - potential breakout ahead")

    print("\n" + "="*70)
    print("REACTION TREND SYSTEM INTEGRATION COMPLETE")
    print("="*70)

# Create the complete integrated visualization
plot_complete_wilder_reaction_trend_system(df, reaction_trend_df, adx_df, vi_df, additional_asi_analysis)

# Final Summary
print("\n" + "="*70)
print("WILDER'S NEW CONCEPTS IN TECHNICAL TRADING SYSTEMS")
print("COMPLETE IMPLEMENTATION INCLUDING REACTION TREND SYSTEM")
print("="*70)
print("\nAll Systems Implemented:")
print("1. ✅ Parabolic SAR System")
print("2. ✅ Volatility Index & System")
print("3. ✅ Directional Movement Index (DMI)")
print("4. ✅ Accumulation Swing Index (ASI)")
print("5. ✅ Momentum Concept & Trend Balance Point")
print("6. ✅ Relative Strength Index (RSI)")
print("7. ✅ Reaction Trend System")
print("8. ✅ Commodity Selection Index (CSI)")
print("\nThe Reaction Trend System adds a unique anti-trend/trend hybrid approach")
print("that complements Wilder's other trend-following systems.")
print("="*70)

# COMPLETE SELF-CONTAINED WILDER'S TECHNICAL ANALYSIS SYSTEM WITH VISUALIZATION
# This cell contains everything needed - no dependencies on previous cells

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from datetime import datetime, timedelta

# ========== DATA GENERATION ==========
def generate_synthetic_ohlc(n_bars=500, trend_prob=0.7, volatility=0.001):
    """Generate synthetic OHLC data with trending behavior."""
    np.random.seed(42)

    dates = [datetime.now() - timedelta(hours=i) for i in range(n_bars)][::-1]

    # Start price
    price = 1.0
    trend = 1

    opens, highs, lows, closes = [], [], [], []

    for i in range(n_bars):
        # Occasionally change trend
        if np.random.random() > trend_prob:
            trend *= -1

        # Generate bar
        open_price = price

        # Trend component + random walk
        change = trend * volatility * np.random.random() + (np.random.random() - 0.5) * volatility * 2
        close_price = open_price * (1 + change)

        # High and low
        intrabar_vol = volatility * np.random.random()
        high_price = max(open_price, close_price) * (1 + intrabar_vol * np.random.random())
        low_price = min(open_price, close_price) * (1 - intrabar_vol * np.random.random())

        opens.append(open_price)
        highs.append(high_price)
        lows.append(low_price)
        closes.append(close_price)

        price = close_price

    return pd.DataFrame({
        'Open': opens,
        'High': highs,
        'Low': lows,
        'Close': closes
    }, index=pd.DatetimeIndex(dates))

# ========== ALL INDICATOR CALCULATIONS ==========
def calculate_swing_index(df):
    """Calculate Swing Index (SI) for forex markets (without K/L factor)."""
    si_values = [0]  # First SI is 0

    for i in range(1, len(df)):
        # Current and previous values
        c1, c2 = df['Close'].iloc[i-1], df['Close'].iloc[i]
        o1, o2 = df['Open'].iloc[i-1], df['Open'].iloc[i]
        h1, h2 = df['High'].iloc[i-1], df['High'].iloc[i]
        l1, l2 = df['Low'].iloc[i-1], df['Low'].iloc[i]

        # Calculate R
        diff_hc = abs(h2 - c1)
        diff_lc = abs(l2 - c1)
        diff_hl = abs(h2 - l2)

        k = max(diff_hc, diff_lc)

        if diff_hc >= diff_lc and diff_hc >= diff_hl:
            r = diff_hc - 0.5 * diff_lc + 0.25 * abs(c1 - o1)
        elif diff_lc >= diff_hc and diff_lc >= diff_hl:
            r = diff_lc - 0.5 * diff_hc + 0.25 * abs(c1 - o1)
        else:
            r = diff_hl + 0.25 * abs(c1 - o1)

        # Prevent division by zero
        if r == 0:
            si = 0
        else:
            # SI formula for forex (no K/L factor)
            si = 50 * ((c2 - c1 + 0.5 * (c2 - o2) + 0.25 * (c1 - o1)) / r)

        si_values.append(si)

    # Calculate ASI (cumulative sum)
    asi_values = np.cumsum(si_values)

    return si_values, asi_values

def detect_swing_points(asi_values, min_distance=10, confirmation_bars=1):
    """Detect High Swing Points (HSP) and Low Swing Points (LSP) in ASI."""
    potential_hsp = []
    potential_lsp = []

    for i in range(confirmation_bars, len(asi_values) - confirmation_bars):
        # Check if it's a high swing point
        is_high_swing = True
        for j in range(1, confirmation_bars + 1):
            if asi_values[i] <= asi_values[i-j] or asi_values[i] <= asi_values[i+j]:
                is_high_swing = False
                break

        # Check if it's a low swing point
        is_low_swing = True
        for j in range(1, confirmation_bars + 1):
            if asi_values[i] >= asi_values[i-j] or asi_values[i] >= asi_values[i+j]:
                is_low_swing = False
                break

        if is_high_swing:
            potential_hsp.append((i, asi_values[i]))
        elif is_low_swing:
            potential_lsp.append((i, asi_values[i]))

    # Filter by minimum distance
    hsp_indices = filter_swing_points_by_distance(potential_hsp, min_distance, is_high=True)
    lsp_indices = filter_swing_points_by_distance(potential_lsp, min_distance, is_high=False)

    # Enforce alternation
    hsp_indices, lsp_indices = enforce_alternating_swings(hsp_indices, lsp_indices, asi_values)

    return hsp_indices, lsp_indices

def filter_swing_points_by_distance(swing_points, min_distance, is_high=True):
    """Filter swing points to ensure minimum distance between them."""
    if not swing_points or min_distance <= 1:
        return [sp[0] for sp in swing_points]

    filtered = []
    i = 0

    while i < len(swing_points):
        group = [swing_points[i]]
        j = i + 1

        while j < len(swing_points) and swing_points[j][0] - swing_points[i][0] < min_distance:
            group.append(swing_points[j])
            j += 1

        if is_high:
            best = max(group, key=lambda x: x[1])
        else:
            best = min(group, key=lambda x: x[1])

        filtered.append(best[0])
        i = j

    return filtered

def enforce_alternating_swings(hsp_indices, lsp_indices, asi_values):
    """Ensure swing points alternate between highs and lows."""
    if not hsp_indices and not lsp_indices:
        return [], []

    all_swings = []
    for idx in hsp_indices:
        all_swings.append((idx, 'H', asi_values[idx]))
    for idx in lsp_indices:
        all_swings.append((idx, 'L', asi_values[idx]))

    all_swings.sort(key=lambda x: x[0])

    filtered_swings = []
    last_type = None
    current_group = []

    for swing in all_swings:
        idx, swing_type, value = swing

        if swing_type == last_type:
            current_group.append(swing)
        else:
            if current_group:
                if last_type == 'H':
                    best = max(current_group, key=lambda x: x[2])
                else:
                    best = min(current_group, key=lambda x: x[2])
                filtered_swings.append(best)

            current_group = [swing]
            last_type = swing_type

    if current_group:
        if last_type == 'H':
            best = max(current_group, key=lambda x: x[2])
        else:
            best = min(current_group, key=lambda x: x[2])
        filtered_swings.append(best)

    final_hsp = [s[0] for s in filtered_swings if s[1] == 'H']
    final_lsp = [s[0] for s in filtered_swings if s[1] == 'L']

    return final_hsp, final_lsp

def calculate_kama(values, period=10, fast_ema_period=2, slow_ema_period=30):
    """Calculate Kaufman's Adaptive Moving Average (KAMA)."""
    n = len(values)
    kama = np.zeros(n)

    fastest_sc = 2 / (fast_ema_period + 1)
    slowest_sc = 2 / (slow_ema_period + 1)

    if n < period + 1:
        return kama

    kama[period] = values[period]

    for i in range(period + 1, n):
        direction = abs(values[i] - values[i - period])

        volatility = 0
        for j in range(i - period + 1, i + 1):
            volatility += abs(values[j] - values[j - 1])

        if volatility != 0:
            er = direction / volatility
        else:
            er = 0

        sc = (er * (fastest_sc - slowest_sc) + slowest_sc) ** 2
        kama[i] = kama[i - 1] + sc * (values[i] - kama[i - 1])

    return kama

def calculate_rsi(values, period=14):
    """Calculate RSI according to Wilder's method."""
    deltas = np.diff(values)
    gains = np.where(deltas > 0, deltas, 0)
    losses = np.where(deltas < 0, -deltas, 0)

    rsi = np.full(len(values), np.nan)

    if len(gains) >= period:
        avg_gain = np.mean(gains[:period])
        avg_loss = np.mean(losses[:period])

        if avg_loss != 0:
            rs = avg_gain / avg_loss
            rsi[period] = 100 - (100 / (1 + rs))
        else:
            rsi[period] = 100

        for i in range(period + 1, len(values)):
            avg_gain = (avg_gain * (period - 1) + gains[i-1]) / period
            avg_loss = (avg_loss * (period - 1) + losses[i-1]) / period

            if avg_loss != 0:
                rs = avg_gain / avg_loss
                rsi[i] = 100 - (100 / (1 + rs))
            else:
                rsi[i] = 100

    return rsi

def calculate_parabolic_sar(df, af_start=0.02, af_increment=0.02, af_max=0.20, pip_size=0.0001):
    """Calculate Parabolic SAR based on Welles Wilder's method."""
    n = len(df)

    sar = np.zeros(n)
    position = np.zeros(n)
    af = np.zeros(n)
    ep = np.zeros(n)

    sar[0] = df['Low'].iloc[0]
    position[0] = 1
    af[0] = af_start
    ep[0] = df['High'].iloc[0]

    for i in range(1, n):
        if position[i-1] == 1:  # Currently long
            if df['Low'].iloc[i] <= sar[i-1]:
                position[i] = -1
                sar[i] = ep[i-1]
                ep[i] = df['Low'].iloc[i]
                af[i] = af_start
            else:
                position[i] = 1
                sar[i] = sar[i-1] + af[i-1] * (ep[i-1] - sar[i-1])
                sar[i] = min(sar[i], df['Low'].iloc[i-1], df['Low'].iloc[i])

                if df['High'].iloc[i] > ep[i-1]:
                    ep[i] = df['High'].iloc[i]
                    af[i] = min(af[i-1] + af_increment, af_max)
                else:
                    ep[i] = ep[i-1]
                    af[i] = af[i-1]

        else:  # Currently short
            if df['High'].iloc[i] >= sar[i-1]:
                position[i] = 1
                sar[i] = ep[i-1]
                ep[i] = df['High'].iloc[i]
                af[i] = af_start
            else:
                position[i] = -1
                sar[i] = sar[i-1] + af[i-1] * (ep[i-1] - sar[i-1])
                sar[i] = max(sar[i], df['High'].iloc[i-1], df['High'].iloc[i])

                if df['Low'].iloc[i] < ep[i-1]:
                    ep[i] = df['Low'].iloc[i]
                    af[i] = min(af[i-1] + af_increment, af_max)
                else:
                    ep[i] = ep[i-1]
                    af[i] = af[i-1]

    psar_delta = ((df['Close'].values - sar) * position) / pip_size

    return {
        'sar': sar,
        'position': position,
        'af': af,
        'ep': ep,
        'psar_delta': psar_delta
    }

def calculate_volatility_index(df, period=14):
    """Calculate Volatility Index (ATR) according to Welles Wilder's method."""
    n = len(df)

    true_range = np.zeros(n)
    true_range[0] = df['High'].iloc[0] - df['Low'].iloc[0]

    for i in range(1, n):
        high_low = df['High'].iloc[i] - df['Low'].iloc[i]
        high_close = abs(df['High'].iloc[i] - df['Close'].iloc[i-1])
        low_close = abs(df['Low'].iloc[i] - df['Close'].iloc[i-1])
        true_range[i] = max(high_low, high_close, low_close)

    atr = np.zeros(n)

    if n >= period:
        atr[period-1] = np.mean(true_range[:period])

        for i in range(period, n):
            atr[i] = (atr[i-1] * (period - 1) + true_range[i]) / period

    return {
        'true_range': true_range,
        'atr': atr,
        'vi': atr.copy()
    }

def calculate_volatility_system(vi_df, arc_constant=3.0):
    """Implement Wilder's Volatility System using the Volatility Index."""
    n = len(vi_df)

    position = np.zeros(n)
    sic = np.zeros(n)
    sar = np.zeros(n)
    arc = vi_df['atr_14'].values * arc_constant

    start_idx = 14

    position[start_idx] = 1
    sic[start_idx] = vi_df['close'].iloc[start_idx]
    sar[start_idx] = sic[start_idx] - arc[start_idx]

    for i in range(start_idx + 1, n):
        close = vi_df['close'].iloc[i]

        if position[i-1] == 1:  # Currently long
            sic[i] = max(sic[i-1], close)

            if close <= sar[i-1]:
                position[i] = -1
                sic[i] = close
                sar[i] = sic[i] + arc[i]
            else:
                position[i] = 1
                sar[i] = sic[i] - arc[i]

        else:  # Currently short
            sic[i] = min(sic[i-1], close)

            if close >= sar[i-1]:
                position[i] = 1
                sic[i] = close
                sar[i] = sic[i] - arc[i]
            else:
                position[i] = -1
                sar[i] = sic[i] + arc[i]

    vi_df['position'] = position
    vi_df['sic'] = sic
    vi_df['sar'] = sar
    vi_df['arc'] = arc

    return vi_df

def calculate_directional_movement(df, period=14):
    """Calculate Directional Movement Index according to Welles Wilder's method."""
    n = len(df)

    plus_dm = np.zeros(n)
    minus_dm = np.zeros(n)
    true_range = np.zeros(n)

    true_range[0] = df['High'].iloc[0] - df['Low'].iloc[0]

    for i in range(1, n):
        high = df['High'].iloc[i]
        low = df['Low'].iloc[i]
        prev_high = df['High'].iloc[i-1]
        prev_low = df['Low'].iloc[i-1]
        prev_close = df['Close'].iloc[i-1]

        up_move = high - prev_high
        down_move = prev_low - low

        if up_move > down_move and up_move > 0:
            plus_dm[i] = up_move
            minus_dm[i] = 0
        elif down_move > up_move and down_move > 0:
            plus_dm[i] = 0
            minus_dm[i] = down_move
        else:
            plus_dm[i] = 0
            minus_dm[i] = 0

        if high <= prev_high and low >= prev_low:
            plus_dm[i] = 0
            minus_dm[i] = 0

        high_low = high - low
        high_close = abs(high - prev_close)
        low_close = abs(low - prev_close)
        true_range[i] = max(high_low, high_close, low_close)

    plus_dm14 = np.zeros(n)
    minus_dm14 = np.zeros(n)
    tr14 = np.zeros(n)

    if n >= period:
        plus_dm14[period-1] = np.sum(plus_dm[:period])
        minus_dm14[period-1] = np.sum(minus_dm[:period])
        tr14[period-1] = np.sum(true_range[:period])

        for i in range(period, n):
            plus_dm14[i] = plus_dm14[i-1] - (plus_dm14[i-1] / period) + plus_dm[i]
            minus_dm14[i] = minus_dm14[i-1] - (minus_dm14[i-1] / period) + minus_dm[i]
            tr14[i] = tr14[i-1] - (tr14[i-1] / period) + true_range[i]

    plus_di = np.zeros(n)
    minus_di = np.zeros(n)

    for i in range(period-1, n):
        if tr14[i] != 0:
            plus_di[i] = (plus_dm14[i] / tr14[i]) * 100
            minus_di[i] = (minus_dm14[i] / tr14[i]) * 100

    dx = np.zeros(n)

    for i in range(period-1, n):
        di_sum = plus_di[i] + minus_di[i]
        if di_sum != 0:
            di_diff = abs(plus_di[i] - minus_di[i])
            dx[i] = (di_diff / di_sum) * 100

    adx = np.zeros(n)

    if n >= 2 * period - 1:
        adx[2*period-2] = np.mean(dx[period-1:2*period-1])

        for i in range(2*period-1, n):
            adx[i] = (adx[i-1] * (period - 1) + dx[i]) / period

    adxr = np.zeros(n)

    for i in range(3*period-2, n):
        adxr[i] = (adx[i] + adx[i-period+1]) / 2

    return {
        'plus_dm': plus_dm,
        'minus_dm': minus_dm,
        'true_range': true_range,
        'plus_dm14': plus_dm14,
        'minus_dm14': minus_dm14,
        'tr14': tr14,
        'plus_di': plus_di,
        'minus_di': minus_di,
        'dx': dx,
        'adx': adx,
        'adxr': adxr
    }

def calculate_momentum_and_tbp(df, target_multiplier=2.0, stop_multiplier=1.0):
    """Calculate Momentum Factor and Trend Balance Point System."""
    n = len(df)

    momentum_factor = np.zeros(n)
    true_range = np.zeros(n)
    tbp = np.zeros(n)
    position = np.zeros(n)

    true_range[0] = df['High'].iloc[0] - df['Low'].iloc[0]

    for i in range(1, n):
        momentum_factor[i] = df['Close'].iloc[i] - df['Close'].iloc[i-1]

        high_low = df['High'].iloc[i] - df['Low'].iloc[i]
        high_close = abs(df['High'].iloc[i] - df['Close'].iloc[i-1])
        low_close = abs(df['Low'].iloc[i] - df['Close'].iloc[i-1])
        true_range[i] = max(high_low, high_close, low_close)

    for i in range(2, n):
        mf_1 = momentum_factor[i-1]
        mf_2 = momentum_factor[i-2]

        if i > 2 and tbp[i-1] > 0:
            if df['Close'].iloc[i] > tbp[i-1]:
                position[i] = 1
            elif df['Close'].iloc[i] < tbp[i-1]:
                position[i] = -1
            else:
                position[i] = position[i-1]
        else:
            if momentum_factor[i] > max(mf_1, mf_2):
                position[i] = 1
            elif momentum_factor[i] < min(mf_1, mf_2):
                position[i] = -1
            else:
                position[i] = position[i-1] if i > 0 else 0

        if position[i] == 1:
            tbp[i] = df['Close'].iloc[i] + min(mf_1, mf_2)
        elif position[i] == -1:
            tbp[i] = df['Close'].iloc[i] + max(mf_1, mf_2)
        else:
            tbp[i] = df['Close'].iloc[i]

    target = np.zeros(n)
    stop = np.zeros(n)

    for i in range(1, n):
        if position[i] == 1:
            target[i] = df['Close'].iloc[i] + true_range[i] * target_multiplier
            stop[i] = df['Close'].iloc[i] - true_range[i] * stop_multiplier
        elif position[i] == -1:
            target[i] = df['Close'].iloc[i] - true_range[i] * target_multiplier
            stop[i] = df['Close'].iloc[i] + true_range[i] * stop_multiplier

    return {
        'momentum_factor': momentum_factor,
        'true_range': true_range,
        'tbp': tbp,
        'position': position,
        'target': target,
        'stop': stop
    }

def calculate_reaction_trend_system(df):
    """Calculate Reaction Trend System according to Welles Wilder's method."""
    n = len(df)

    x_values = np.zeros(n)
    b1_values = np.zeros(n)
    s1_values = np.zeros(n)
    hbop_values = np.zeros(n)
    lbop_values = np.zeros(n)

    day_sequence = ['B', 'O', 'S', 'O']
    day_type = []

    position = np.zeros(n)
    mode = ['REACTION'] * n
    trailing_stop = np.zeros(n)

    for i in range(n):
        x_values[i] = (df['High'].iloc[i] + df['Low'].iloc[i] + df['Close'].iloc[i]) / 3

        if i < n - 1:
            b1_values[i + 1] = 2 * x_values[i] - df['High'].iloc[i]
            s1_values[i + 1] = 2 * x_values[i] - df['Low'].iloc[i]
            hbop_values[i + 1] = 2 * x_values[i] - 2 * df['Low'].iloc[i] + df['High'].iloc[i]
            lbop_values[i + 1] = 2 * x_values[i] - 2 * df['High'].iloc[i] + df['Low'].iloc[i]

    for i in range(n):
        day_type.append(day_sequence[i % 4])

    for i in range(1, n):
        current_day = day_type[i]

        if df['High'].iloc[i] >= hbop_values[i] and hbop_values[i] > 0:
            mode[i] = 'TREND'
            position[i] = 1
            if i >= 2:
                trailing_stop[i] = min(df['Low'].iloc[i-1], df['Low'].iloc[i-2])
            else:
                trailing_stop[i] = df['Low'].iloc[i-1]

        elif df['Low'].iloc[i] <= lbop_values[i] and lbop_values[i] > 0:
            mode[i] = 'TREND'
            position[i] = -1
            if i >= 2:
                trailing_stop[i] = max(df['High'].iloc[i-1], df['High'].iloc[i-2])
            else:
                trailing_stop[i] = df['High'].iloc[i-1]

        elif mode[i-1] == 'TREND':
            mode[i] = 'TREND'

            if position[i-1] == 1:
                if i >= 2:
                    trailing_stop[i] = min(df['Low'].iloc[i-1], df['Low'].iloc[i-2])
                else:
                    trailing_stop[i] = df['Low'].iloc[i-1]

                if df['Low'].iloc[i] <= trailing_stop[i]:
                    position[i] = 0
                    mode[i] = 'REACTION'
                else:
                    position[i] = 1

            elif position[i-1] == -1:
                if i >= 2:
                    trailing_stop[i] = max(df['High'].iloc[i-1], df['High'].iloc[i-2])
                else:
                    trailing_stop[i] = df['High'].iloc[i-1]

                if df['High'].iloc[i] >= trailing_stop[i]:
                    position[i] = 0
                    mode[i] = 'REACTION'
                else:
                    position[i] = -1
        else:
            mode[i] = 'REACTION'

            if current_day == 'B':
                if df['Low'].iloc[i] <= b1_values[i] and b1_values[i] > 0:
                    position[i] = 1
                else:
                    position[i] = position[i-1]

            elif current_day == 'S':
                if df['High'].iloc[i] >= s1_values[i] and s1_values[i] > 0:
                    position[i] = -1
                else:
                    position[i] = position[i-1]
            else:
                if position[i-1] == 1 and current_day == 'S':
                    if df['High'].iloc[i] < s1_values[i]:
                        position[i] = 0
                    else:
                        position[i] = position[i-1]
                elif position[i-1] == -1 and current_day == 'B':
                    if df['Low'].iloc[i] > b1_values[i]:
                        position[i] = 0
                    else:
                        position[i] = position[i-1]
                else:
                    position[i] = position[i-1]

    return {
        'x': x_values,
        'b1': b1_values,
        's1': s1_values,
        'hbop': hbop_values,
        'lbop': lbop_values,
        'day_type': day_type,
        'position': position,
        'mode': mode,
        'trailing_stop': trailing_stop
    }

def calculate_additional_asi_analysis(df, si_values, asi_values, hsp_indices, lsp_indices, n_lags=10):
    """Calculate additional ASI metrics including slopes and acceleration."""
    n = len(df)

    # Initialize arrays
    asi_slope = np.full(n, np.nan)
    asi_acceleration = np.full(n, np.nan)
    slope_hsps = np.full(n, np.nan)
    slope_lsps = np.full(n, np.nan)
    is_hsp = np.zeros(n)
    is_lsp = np.zeros(n)
    swing_regime = [''] * n

    # Mark HSP and LSP
    for idx in hsp_indices:
        is_hsp[idx] = 1
    for idx in lsp_indices:
        is_lsp[idx] = 1

    # Calculate ASI slope
    for i in range(n_lags, n):
        asi_slope[i] = (asi_values[i] - asi_values[i - n_lags]) / n_lags

    # Calculate ASI acceleration
    for i in range(2 * n_lags, n):
        if not np.isnan(asi_slope[i]) and not np.isnan(asi_slope[i - n_lags]):
            asi_acceleration[i] = (asi_slope[i] - asi_slope[i - n_lags]) / n_lags

    # Calculate swing point slopes
    for i in range(n):
        recent_hsps = [idx for idx in hsp_indices if idx <= i][-2:]
        if len(recent_hsps) == 2:
            hsp1_idx, hsp2_idx = recent_hsps[0], recent_hsps[1]
            bars_between = hsp2_idx - hsp1_idx
            if bars_between > 0:
                slope_hsps[i] = (asi_values[hsp2_idx] - asi_values[hsp1_idx]) / bars_between

        recent_lsps = [idx for idx in lsp_indices if idx <= i][-2:]
        if len(recent_lsps) == 2:
            lsp1_idx, lsp2_idx = recent_lsps[0], recent_lsps[1]
            bars_between = lsp2_idx - lsp1_idx
            if bars_between > 0:
                slope_lsps[i] = (asi_values[lsp2_idx] - asi_values[lsp1_idx]) / bars_between

    # Calculate swing regime
    for i in range(n):
        recent_highs = [idx for idx in hsp_indices if idx <= i][-2:]
        recent_lows = [idx for idx in lsp_indices if idx <= i][-2:]

        if len(recent_highs) == 2 and len(recent_lows) == 2:
            recent_high = asi_values[recent_highs[-1]]
            prev_high = asi_values[recent_highs[-2]]
            recent_low = asi_values[recent_lows[-1]]
            prev_low = asi_values[recent_lows[-2]]

            has_higher_highs = recent_high > prev_high
            has_higher_lows = recent_low > prev_low

            if has_higher_highs and has_higher_lows:
                swing_regime[i] = 'Uptrend'
            elif not has_higher_highs and not has_higher_lows:
                swing_regime[i] = 'Downtrend'
            elif has_higher_highs and not has_higher_lows:
                swing_regime[i] = 'Bull_Div'
            else:
                swing_regime[i] = 'Bear_Div'

    return {
        'si': si_values,
        'asi': asi_values,
        'asi_slope': asi_slope,
        'asi_acceleration': asi_acceleration,
        'is_HSP': is_hsp,
        'is_LSP': is_lsp,
        'Regime': swing_regime,
        'slope_hsps': slope_hsps,
        'slope_lsps': slope_lsps
    }

# ========== VISUALIZATION FUNCTION ==========
def plot_comprehensive_analysis(master_df):
    """
    Create comprehensive visualization of all Wilder's indicators.
    This function is self-contained and uses only the master_df parameter.
    """
    import matplotlib.pyplot as plt
    import matplotlib.patches as mpatches
    from matplotlib.gridspec import GridSpec
    import numpy as np

    # Set up the figure with GridSpec for flexible subplot sizes
    fig = plt.figure(figsize=(20, 24))
    gs = GridSpec(7, 1, figure=fig, height_ratios=[2, 1.5, 1.5, 1.5, 1, 1, 1], hspace=0.3)

    # Common time axis
    time_axis = master_df.index

    # 1. Price Chart with SAR
    ax1 = fig.add_subplot(gs[0])
    ax1.plot(time_axis, master_df['high'], 'g-', alpha=0.3, label='High')
    ax1.plot(time_axis, master_df['low'], 'r-', alpha=0.3, label='Low')
    ax1.plot(time_axis, master_df['close'], 'b-', linewidth=2, label='Close')

    # Add SAR
    ax1.scatter(time_axis[master_df['sar_uptrend']],
                master_df.loc[master_df['sar_uptrend'], 'sar'],
                color='green', s=20, label='SAR Up', alpha=0.7)
    ax1.scatter(time_axis[~master_df['sar_uptrend']],
                master_df.loc[~master_df['sar_uptrend'], 'sar'],
                color='red', s=20, label='SAR Down', alpha=0.7)

    # Highlight swing points
    if 'is_hsp' in master_df.columns:
        hsp_mask = master_df['is_hsp'].fillna(False)
        lsp_mask = master_df['is_lsp'].fillna(False)
        ax1.scatter(time_axis[hsp_mask], master_df.loc[hsp_mask, 'high'],
                    marker='^', s=100, color='darkgreen', label='HSP', zorder=5)
        ax1.scatter(time_axis[lsp_mask], master_df.loc[lsp_mask, 'low'],
                    marker='v', s=100, color='darkred', label='LSP', zorder=5)

    ax1.set_title('Price Chart with Parabolic SAR and Swing Points', fontsize=14, fontweight='bold')
    ax1.set_ylabel('Price', fontsize=12)
    ax1.legend(loc='upper left', ncol=3, fontsize=10)
    ax1.grid(True, alpha=0.3)

    # 2. ASI with KAMA overlays
    ax2 = fig.add_subplot(gs[1], sharex=ax1)

    # Color-code ASI based on swing points
    colors = ['gray'] * len(master_df)
    if 'is_hsp' in master_df.columns and 'is_lsp' in master_df.columns:
        for i in range(len(master_df)):
            if master_df['is_hsp'].iloc[i]:
                colors[i] = 'darkgreen'
            elif master_df['is_lsp'].iloc[i]:
                colors[i] = 'darkred'

    # Plot ASI bars
    ax2.bar(time_axis, master_df['asi'], color=colors, alpha=0.6, label='ASI')

    # Add KAMA lines
    ax2.plot(time_axis, master_df['kama_asi_5'], 'g-', linewidth=2, label='KAMA(5)', alpha=0.8)
    ax2.plot(time_axis, master_df['kama_asi_10'], 'r--', linewidth=2, label='KAMA(10)', alpha=0.8)

    # Add shading for bullish/bearish signals
    bullish_mask = master_df['kama_asi_5'] > master_df['kama_asi_10']
    bearish_mask = master_df['kama_asi_5'] < master_df['kama_asi_10']

    # Fill between for visual clarity
    ax2.fill_between(time_axis, master_df['asi'], 0,
                     where=bullish_mask, color='green', alpha=0.1, label='Bullish')
    ax2.fill_between(time_axis, master_df['asi'], 0,
                     where=bearish_mask, color='red', alpha=0.1, label='Bearish')

    ax2.axhline(y=0, color='black', linestyle='-', alpha=0.3)
    ax2.set_title('Accumulation Swing Index (ASI) with KAMA(5) and KAMA(10)', fontsize=14, fontweight='bold')
    ax2.set_ylabel('ASI Value', fontsize=12)
    ax2.legend(loc='upper left', ncol=4, fontsize=10)
    ax2.grid(True, alpha=0.3)

    # 3. RSI Panel
    ax3 = fig.add_subplot(gs[2], sharex=ax1)
    ax3.plot(time_axis, master_df['rsi'], 'purple', linewidth=2, label='RSI(14)')
    if 'rsi_asi' in master_df.columns:
        ax3.plot(time_axis, master_df['rsi_asi'], 'orange', linewidth=1.5, label='RSI(ASI)', alpha=0.7)

    # RSI levels
    ax3.axhline(y=70, color='red', linestyle='--', alpha=0.5, label='Overbought')
    ax3.axhline(y=30, color='green', linestyle='--', alpha=0.5, label='Oversold')
    ax3.axhline(y=50, color='gray', linestyle='-', alpha=0.3)

    # Fill overbought/oversold areas
    ax3.fill_between(time_axis, 70, 100, color='red', alpha=0.1)
    ax3.fill_between(time_axis, 0, 30, color='green', alpha=0.1)

    ax3.set_title('Relative Strength Index (RSI)', fontsize=14, fontweight='bold')
    ax3.set_ylabel('RSI', fontsize=12)
    ax3.set_ylim(0, 100)
    ax3.legend(loc='upper left', ncol=4, fontsize=10)
    ax3.grid(True, alpha=0.3)

    # 4. Directional Movement (DMI)
    ax4 = fig.add_subplot(gs[3], sharex=ax1)
    ax4.plot(time_axis, master_df['di_plus'], 'green', linewidth=2, label='+DI')
    ax4.plot(time_axis, master_df['di_minus'], 'red', linewidth=2, label='-DI')
    ax4.plot(time_axis, master_df['adx'], 'blue', linewidth=2, label='ADX', alpha=0.7)

    # ADX levels
    ax4.axhline(y=25, color='gray', linestyle='--', alpha=0.5, label='Trend Strength')
    ax4.axhline(y=40, color='darkgray', linestyle='--', alpha=0.5)

    # Highlight strong trends
    strong_trend = master_df['adx'] > 25
    ax4.fill_between(time_axis, 0, 100, where=strong_trend, color='yellow', alpha=0.1)

    ax4.set_title('Directional Movement Index (DMI)', fontsize=14, fontweight='bold')
    ax4.set_ylabel('DMI Value', fontsize=12)
    ax4.set_ylim(0, 100)
    ax4.legend(loc='upper left', ncol=5, fontsize=10)
    ax4.grid(True, alpha=0.3)

    # 5. ATR (Volatility)
    ax5 = fig.add_subplot(gs[4], sharex=ax1)
    ax5.plot(time_axis, master_df['atr'], 'darkblue', linewidth=2, label='ATR(14)')
    ax5.fill_between(time_axis, 0, master_df['atr'], alpha=0.3, color='lightblue')

    # Add rolling mean and std bands
    atr_mean = master_df['atr'].rolling(50, min_periods=1).mean()
    atr_std = master_df['atr'].rolling(50, min_periods=1).std()
    ax5.plot(time_axis, atr_mean, 'red', linestyle='--', label='ATR Mean', alpha=0.7)
    ax5.fill_between(time_axis, atr_mean - atr_std, atr_mean + atr_std,
                     alpha=0.2, color='red', label='±1 STD')

    ax5.set_title('Average True Range (Volatility)', fontsize=14, fontweight='bold')
    ax5.set_ylabel('ATR', fontsize=12)
    ax5.legend(loc='upper left', ncol=3, fontsize=10)
    ax5.grid(True, alpha=0.3)

    # 6. Momentum/TBP
    ax6 = fig.add_subplot(gs[5], sharex=ax1)
    if 'momentum' in master_df.columns:
        ax6.plot(time_axis, master_df['momentum'], 'purple', linewidth=2, label='Momentum')
    if 'tbp' in master_df.columns:
        ax6.bar(time_axis, master_df['tbp'], color='orange', alpha=0.5, label='TBP')

    ax6.axhline(y=0, color='black', linestyle='-', alpha=0.5)
    ax6.set_title('Momentum and Trend Balance Point', fontsize=14, fontweight='bold')
    ax6.set_ylabel('Value', fontsize=12)
    ax6.legend(loc='upper left', fontsize=10)
    ax6.grid(True, alpha=0.3)

    # 7. Market Regime
    ax7 = fig.add_subplot(gs[6], sharex=ax1)

    # Create regime color map
    regime_colors = {
        'Uptrend': 'green',
        'Downtrend': 'red',
        'Bull_Div': 'lightgreen',
        'Bear_Div': 'lightcoral'
    }

    if 'market_regime' in master_df.columns:
        # Plot regime as colored background
        for regime, color in regime_colors.items():
            mask = master_df['market_regime'] == regime
            ax7.fill_between(time_axis, 0, 1, where=mask,
                           color=color, alpha=0.3, label=regime)

    # Add reaction trend if available
    if 'trend_reaction' in master_df.columns:
        trend_values = master_df['trend_reaction'].map({'Up': 1, 'Down': -1, 'Neutral': 0})
        ax7.plot(time_axis, trend_values * 0.5 + 0.5, 'black', linewidth=2,
                label='Reaction Trend', alpha=0.7)

    ax7.set_title('Market Regime Classification', fontsize=14, fontweight='bold')
    ax7.set_ylabel('Regime', fontsize=12)
    ax7.set_ylim(0, 1)
    ax7.set_xlabel('Time', fontsize=12)
    ax7.legend(loc='upper left', ncol=5, fontsize=10)
    ax7.grid(True, alpha=0.3)

    # Remove x-axis labels from all but bottom plot
    for ax in [ax1, ax2, ax3, ax4, ax5, ax6]:
        ax.set_xticklabels([])

    plt.suptitle("Welles Wilder's Complete Technical Trading System Analysis",
                 fontsize=16, fontweight='bold', y=0.995)

    plt.tight_layout()
    return fig

# ========== MAIN EXECUTION ==========
# Generate data
print("Generating synthetic OHLC data...")
df = generate_synthetic_ohlc(n_bars=500)

# Calculate all indicators
print("Calculating all Wilder indicators...")

# 1. Calculate Swing Index and ASI
si_values, asi_values = calculate_swing_index(df)

# 2. Detect swing points
hsp_indices, lsp_indices = detect_swing_points(asi_values, min_distance=10)

# 3. Calculate KAMA of ASI
kama_asi_5 = calculate_kama(asi_values, period=5)
kama_asi_10 = calculate_kama(asi_values, period=10)

# 4. Calculate RSI
price_rsi = calculate_rsi(df['Close'].values)
asi_rsi = calculate_rsi(asi_values)

# 5. Calculate Parabolic SAR
psar_data = calculate_parabolic_sar(df)

# 6. Calculate Volatility Index
vi_data = calculate_volatility_index(df)

# 7. Create VI DataFrame and calculate Volatility System
vi_df = pd.DataFrame({
    'date': df.index,
    'open': df['Open'],
    'high': df['High'],
    'low': df['Low'],
    'close': df['Close'],
    'true_range': vi_data['true_range'],
    'atr_14': vi_data['atr'],
    'vi': vi_data['vi']
})
vi_df = calculate_volatility_system(vi_df)

# 8. Calculate Directional Movement Index
dmi_data = calculate_directional_movement(df)

# 9. Calculate Momentum and TBP
momentum_data = calculate_momentum_and_tbp(df)

# 10. Calculate Reaction Trend System
reaction_data = calculate_reaction_trend_system(df)

# 11. Calculate additional ASI analysis
additional_asi_analysis = calculate_additional_asi_analysis(
    df, si_values, asi_values, hsp_indices, lsp_indices
)

# Create DataFrames for each system
adx_df = pd.DataFrame({
    'date': df.index,
    'plus_dm': dmi_data['plus_dm'],
    'minus_dm': dmi_data['minus_dm'],
    'plus_di': dmi_data['plus_di'],
    'minus_di': dmi_data['minus_di'],
    'dx': dmi_data['dx'],
    'adx': dmi_data['adx'],
    'adxr': dmi_data['adxr']
})

momentum_df = pd.DataFrame({
    'momentum_factor': momentum_data['momentum_factor'],
    'tbp': momentum_data['tbp'],
    'position': momentum_data['position'],
    'target': momentum_data['target'],
    'stop': momentum_data['stop']
})

reaction_trend_df = pd.DataFrame({
    'x': reaction_data['x'],
    'b1': reaction_data['b1'],
    's1': reaction_data['s1'],
    'hbop': reaction_data['hbop'],
    'lbop': reaction_data['lbop'],
    'day_type': reaction_data['day_type'],
    'position': reaction_data['position'],
    'mode': reaction_data['mode'],
    'trailing_stop': reaction_data['trailing_stop']
})

# Add Parabolic SAR and RSI to additional_asi_analysis
additional_asi_analysis['psar'] = psar_data['sar']
additional_asi_analysis['psar_position'] = psar_data['position']
additional_asi_analysis['psar_delta'] = psar_data['psar_delta']
additional_asi_analysis['price_rsi'] = price_rsi
additional_asi_analysis['asi_rsi'] = asi_rsi

# Create master dataframe
print("Creating master DataFrame...")
master_df = pd.DataFrame({
    'date': df.index,
    'open': df['Open'],
    'high': df['High'],
    'low': df['Low'],
    'close': df['Close'],
    'price_change': df['Close'].diff(),
    'price_pct_change': df['Close'].pct_change() * 100,

    # ASI and related
    'si': si_values,
    'asi': asi_values,
    'kama_asi_5': kama_asi_5,
    'kama_asi_10': kama_asi_10,
    'asi_slope': additional_asi_analysis['asi_slope'],
    'asi_acceleration': additional_asi_analysis['asi_acceleration'],
    'is_hsp': additional_asi_analysis['is_HSP'],
    'is_lsp': additional_asi_analysis['is_LSP'],
    'market_regime': additional_asi_analysis['Regime'],
    'slope_hsps': additional_asi_analysis['slope_hsps'],
    'slope_lsps': additional_asi_analysis['slope_lsps'],

    # Parabolic SAR
    'sar': psar_data['sar'],
    'sar_uptrend': psar_data['position'] == 1,
    'psar_position': psar_data['position'],
    'psar_delta': psar_data['psar_delta'],

    # RSI
    'rsi': price_rsi,
    'rsi_asi': asi_rsi,

    # Volatility
    'true_range': vi_data['true_range'],
    'atr': vi_data['atr'],
    'vi_position': vi_df['position'].values,
    'vi_sar': vi_df['sar'].values,
    'vi_sic': vi_df['sic'].values,
    'vi_arc': vi_df['arc'].values,

    # DMI
    'plus_dm': dmi_data['plus_dm'],
    'minus_dm': dmi_data['minus_dm'],
    'di_plus': dmi_data['plus_di'],
    'di_minus': dmi_data['minus_di'],
    'dx': dmi_data['dx'],
    'adx': dmi_data['adx'],
    'adxr': dmi_data['adxr'],

    # Momentum
    'momentum': momentum_data['momentum_factor'],
    'tbp': momentum_data['tbp'],
    'momentum_position': momentum_data['position'],
    'momentum_target': momentum_data['target'],
    'momentum_stop': momentum_data['stop'],

    # Reaction Trend
    'x': reaction_data['x'],
    'b1': reaction_data['b1'],
    's1': reaction_data['s1'],
    'hbop': reaction_data['hbop'],
    'lbop': reaction_data['lbop'],
    'day_type': reaction_data['day_type'],
    'reaction_position': reaction_data['position'],
    'reaction_mode': reaction_data['mode'],
    'reaction_trailing_stop': reaction_data['trailing_stop']
})

# Calculate derived features
master_df['dmi_trend'] = np.where(master_df['di_plus'] > master_df['di_minus'], 1, -1)

# Combined position signal
position_sum = (master_df['psar_position'] +
               master_df['vi_position'] +
               master_df['momentum_position'] +
               master_df['reaction_position'])
master_df['combined_position_signal'] = position_sum / 4

# Volatility regime
atr_mean = master_df['atr'][master_df['atr'] > 0].mean()
master_df['volatility_regime'] = pd.cut(
    master_df['atr'],
    bins=[0, atr_mean*0.5, atr_mean, atr_mean*1.5, float('inf')],
    labels=['Low', 'Normal', 'High', 'Very High']
)

# Trend strength regime
master_df['trend_strength'] = pd.cut(
    master_df['adx'],
    bins=[0, 20, 25, 40, 100],
    labels=['No Trend', 'Weak', 'Moderate', 'Strong']
)

print(f"\nCreated Master DataFrame with {len(master_df)} rows and {len(master_df.columns)} columns")

# Create the visualization
fig = plot_comprehensive_analysis(master_df)
plt.show()

# Print summary statistics
print("\n=== Summary Statistics ===")
print(f"Total bars analyzed: {len(master_df)}")
print(f"Date range: {master_df.index[0]} to {master_df.index[-1]}")

if 'is_hsp' in master_df.columns and 'is_lsp' in master_df.columns:
    print(f"High Swing Points (HSP): {master_df['is_hsp'].sum()}")
    print(f"Low Swing Points (LSP): {master_df['is_lsp'].sum()}")

if 'market_regime' in master_df.columns:
    print("\nMarket Regime Distribution:")
    regime_counts = master_df['market_regime'].value_counts()
    for regime, count in regime_counts.items():
        if regime:  # Skip empty regimes
            print(f"  {regime}: {count} ({count/len(master_df)*100:.1f}%)")

print("\nIndicator Ranges:")
print(f"  ASI: [{master_df['asi'].min():.2f}, {master_df['asi'].max():.2f}]")
print(f"  RSI: [{master_df['rsi'].min():.2f}, {master_df['rsi'].max():.2f}]")
print(f"  ATR: [{master_df['atr'].min():.4f}, {master_df['atr'].max():.4f}]")
print(f"  ADX: [{master_df['adx'].min():.2f}, {master_df['adx'].max():.2f}]")

print("\nKAMA Analysis:")
print(f"  KAMA(5) Current: {master_df['kama_asi_5'].iloc[-1]:.2f}")
print(f"  KAMA(10) Current: {master_df['kama_asi_10'].iloc[-1]:.2f}")
print(f"  ASI Current: {master_df['asi'].iloc[-1]:.2f}")

# Check KAMA crossover
if master_df['kama_asi_5'].iloc[-1] > master_df['kama_asi_10'].iloc[-1]:
    print("  Signal: BULLISH (KAMA(5) > KAMA(10))")
else:
    print("  Signal: BEARISH (KAMA(5) < KAMA(10))")

print("\n" + "="*50)
print("COMPLETE WILDER'S TECHNICAL ANALYSIS SYSTEM")
print("="*50)

# Final Comprehensive Plot - All Indicators as Subplots
def plot_all_indicators_final(master_df):
    """
    Create the final comprehensive visualization with price and all indicators as subplots.
    """

    # Define subplot layout - 15 rows for all major indicators
    fig, axes = plt.subplots(15, 1, figsize=(20, 45),
                            height_ratios=[3, 2, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.2, 1.2, 1.2, 1.2, 1.2, 1, 1])

    x = np.arange(len(master_df))

    # Define common style parameters
    grid_alpha = 0.3
    line_alpha = 0.8
    fill_alpha = 0.3

    # 1. Price Chart with Candlesticks
    ax1 = axes[0]
    for i in range(len(master_df)):
        color = 'g' if master_df['close'].iloc[i] >= master_df['open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]],
                [master_df['low'].iloc[i], master_df['high'].iloc[i]],
                color=color, linewidth=1, alpha=0.7)
        rect = Rectangle((x[i]-0.3,
                         min(master_df['open'].iloc[i], master_df['close'].iloc[i])),
                        0.6,
                        abs(master_df['close'].iloc[i] - master_df['open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    ax1.set_ylabel('Price', fontsize=11)
    ax1.set_title('OHLC Price Chart', fontsize=12, fontweight='bold')
    ax1.grid(True, alpha=grid_alpha)

    # 2. ASI with KAMA(5) and KAMA(10)
    ax2 = axes[1]

    # Color code ASI based on swing points
    asi_colors = ['orange'] * len(master_df)
    for i in range(len(master_df)):
        if master_df['is_hsp'].iloc[i] == 1:
            asi_colors[i] = 'purple'
        elif master_df['is_lsp'].iloc[i] == 1:
            asi_colors[i] = 'blue'

    ax2.scatter(x, master_df['asi'], c=asi_colors, s=2, alpha=0.7, label='ASI')
    ax2.plot(x, master_df['kama_asi_5'], 'green', linewidth=2,
             label='KAMA(5)', alpha=0.9, linestyle='-')
    ax2.plot(x, master_df['kama_asi_10'], 'red', linewidth=2,
             label='KAMA(10)', alpha=0.9, linestyle='--')

    ax2.axhline(y=0, color='gray', linestyle='-', alpha=0.5)
    ax2.set_ylabel('ASI', fontsize=11)
    ax2.set_title('Accumulation Swing Index with KAMA', fontsize=12, fontweight='bold')
    ax2.legend(loc='upper left', fontsize=9)
    ax2.grid(True, alpha=grid_alpha)

    # 3. ASI Slope
    ax3 = axes[2]
    ax3.plot(x, master_df['asi_slope'], 'darkblue', linewidth=1.2, alpha=line_alpha)
    ax3.fill_between(x, 0, master_df['asi_slope'],
                     where=master_df['asi_slope'] > 0,
                     alpha=fill_alpha, color='green')
    ax3.fill_between(x, 0, master_df['asi_slope'],
                     where=master_df['asi_slope'] < 0,
                     alpha=fill_alpha, color='red')
    ax3.axhline(y=0, color='gray', linestyle='-', alpha=0.5)
    ax3.set_ylabel('ASI Slope', fontsize=11)
    ax3.set_title('ASI Slope (Momentum)', fontsize=12, fontweight='bold')
    ax3.grid(True, alpha=grid_alpha)

    # 4. Swing Point Slopes
    ax4 = axes[3]
    ax4.plot(x, master_df['slope_hsps'], 'purple', linewidth=1.5,
              label='HSP Slope', alpha=line_alpha)
    ax4.plot(x, master_df['slope_lsps'], 'blue', linewidth=1.5,
              label='LSP Slope', alpha=line_alpha)
    ax4.axhline(y=0, color='gray', linestyle='-', alpha=0.5)
    ax4.set_ylabel('Slope', fontsize=11)
    ax4.set_title('Swing Point Slopes', fontsize=12, fontweight='bold')
    ax4.legend(loc='upper left', fontsize=9)
    ax4.grid(True, alpha=grid_alpha)

    # 5. ADX and DI
    ax5 = axes[4]
    ax5.plot(x, master_df['plus_di'], 'green', linewidth=1.2,
             label='+DI', alpha=line_alpha)
    ax5.plot(x, master_df['minus_di'], 'red', linewidth=1.2,
             label='-DI', alpha=line_alpha)
    ax5.plot(x, master_df['adx'], 'blue', linewidth=1.5,
             label='ADX', alpha=0.9)
    ax5.axhline(y=25, color='gray', linestyle='--', alpha=0.5)
    ax5.set_ylabel('DMI', fontsize=11)
    ax5.set_title('Directional Movement Index', fontsize=12, fontweight='bold')
    ax5.legend(loc='upper left', fontsize=9, ncol=3)
    ax5.grid(True, alpha=grid_alpha)
    ax5.set_ylim(0, max(60, master_df['adx'].max() * 1.1))

    # 6. ATR (Volatility)
    ax6 = axes[5]
    ax6.plot(x, master_df['atr_14'], 'purple', linewidth=1.5, alpha=line_alpha)
    ax6.fill_between(x, 0, master_df['atr_14'], alpha=fill_alpha, color='purple')
    atr_mean = master_df['atr_14'][master_df['atr_14'] > 0].mean()
    ax6.axhline(y=atr_mean, color='gray', linestyle=':', alpha=0.5)
    ax6.set_ylabel('ATR', fontsize=11)
    ax6.set_title('Average True Range (Volatility)', fontsize=12, fontweight='bold')
    ax6.grid(True, alpha=grid_alpha)

    # 7. Price RSI
    ax7 = axes[6]
    ax7.plot(x, master_df['price_rsi'], 'blue', linewidth=1.2, alpha=line_alpha)
    ax7.axhline(y=70, color='red', linestyle='--', alpha=0.5)
    ax7.axhline(y=30, color='green', linestyle='--', alpha=0.5)
    ax7.axhline(y=50, color='gray', linestyle='-', alpha=0.3)
    ax7.fill_between(x, 70, 100, alpha=0.1, color='red')
    ax7.fill_between(x, 0, 30, alpha=0.1, color='green')
    ax7.set_ylabel('RSI', fontsize=11)
    ax7.set_ylim(0, 100)
    ax7.set_title('Price RSI', fontsize=12, fontweight='bold')
    ax7.grid(True, alpha=grid_alpha)

    # 8. ASI RSI
    ax8 = axes[7]
    ax8.plot(x, master_df['asi_rsi'], 'purple', linewidth=1.2, alpha=line_alpha)
    ax8.axhline(y=70, color='red', linestyle='--', alpha=0.5)
    ax8.axhline(y=30, color='green', linestyle='--', alpha=0.5)
    ax8.axhline(y=50, color='gray', linestyle='-', alpha=0.3)
    ax8.fill_between(x, 70, 100, alpha=0.1, color='red')
    ax8.fill_between(x, 0, 30, alpha=0.1, color='green')
    ax8.set_ylabel('RSI', fontsize=11)
    ax8.set_ylim(0, 100)
    ax8.set_title('ASI RSI', fontsize=12, fontweight='bold')
    ax8.grid(True, alpha=grid_alpha)

    # 9. Parabolic SAR Position
    ax9 = axes[8]
    psar_colors = ['green' if pos == 1 else 'red' for pos in master_df['psar_position']]
    ax9.bar(x, master_df['psar_position'], color=psar_colors, alpha=0.7, width=0.8)
    ax9.axhline(y=0, color='black', linestyle='-', linewidth=0.5)
    ax9.set_ylabel('Position', fontsize=11)
    ax9.set_ylim(-1.5, 1.5)
    ax9.set_title('Parabolic SAR Position', fontsize=12, fontweight='bold')
    ax9.grid(True, alpha=grid_alpha)

    # 10. Momentum Factor
    ax10 = axes[9]
    mf_colors = ['green' if val > 0 else 'red' for val in master_df['momentum_factor']]
    ax10.bar(x, master_df['momentum_factor'], color=mf_colors, alpha=0.7, width=0.8)
    ax10.axhline(y=0, color='black', linestyle='-', linewidth=1)
    ax10.set_ylabel('MF', fontsize=11)
    ax10.set_title('Momentum Factor', fontsize=12, fontweight='bold')
    ax10.grid(True, alpha=grid_alpha)

    # 11. TBP Position
    ax11 = axes[10]
    tbp_colors = ['green' if pos == 1 else 'red' if pos == -1 else 'gray'
                  for pos in master_df['momentum_position']]
    ax11.bar(x, master_df['momentum_position'], color=tbp_colors, alpha=0.7, width=0.8)
    ax11.axhline(y=0, color='black', linestyle='-', linewidth=0.5)
    ax11.set_ylabel('Position', fontsize=11)
    ax11.set_ylim(-1.5, 1.5)
    ax11.set_title('Momentum/TBP Position', fontsize=12, fontweight='bold')
    ax11.grid(True, alpha=grid_alpha)

    # 12. Reaction Trend Mode
    ax12 = axes[11]
    mode_numeric = np.array([1 if m == 'TREND' else 0 for m in master_df['reaction_mode']])
    ax12.fill_between(x, 0, mode_numeric, where=(mode_numeric == 1),
                     alpha=0.5, color='blue', step='mid')
    ax12.set_ylabel('Mode', fontsize=11)
    ax12.set_ylim(-0.1, 1.1)
    ax12.set_yticks([0, 1])
    ax12.set_yticklabels(['REACTION', 'TREND'])
    ax12.set_title('Reaction Trend Mode', fontsize=12, fontweight='bold')
    ax12.grid(True, alpha=grid_alpha)

    # 13. Combined Position Signal
    ax13 = axes[12]
    pos_colors = ['green' if val > 0 else 'red' if val < 0 else 'gray'
                  for val in master_df['combined_position_signal']]
    ax13.bar(x, master_df['combined_position_signal'],
             color=pos_colors, alpha=0.7, width=0.8)
    ax13.axhline(y=0, color='black', linestyle='-', linewidth=1)
    ax13.set_ylabel('Signal', fontsize=11)
    ax13.set_ylim(-1.2, 1.2)
    ax13.set_title('Combined Position Signal', fontsize=12, fontweight='bold')
    ax13.grid(True, alpha=grid_alpha)

    # 14. Swing Regime
    ax14 = axes[13]
    regime_mapping = {'Uptrend': 3, 'Bull_Div': 2, 'Bear_Div': -2, 'Downtrend': -3, '': 0}
    regime_colors = {'Uptrend': 'darkgreen', 'Bull_Div': 'lightgreen',
                     'Bear_Div': 'orange', 'Downtrend': 'darkred', '': 'gray'}

    regime_numeric = master_df['swing_regime'].map(regime_mapping)
    for regime, color in regime_colors.items():
        mask = master_df['swing_regime'] == regime
        if mask.any():
            ax14.fill_between(x, -4, 4, where=mask, alpha=0.3, color=color)

    ax14.plot(x, regime_numeric, 'black', linewidth=1, alpha=0.5)
    ax14.axhline(y=0, color='gray', linestyle='-', alpha=0.5)
    ax14.set_ylabel('Regime', fontsize=11)
    ax14.set_ylim(-4, 4)
    ax14.set_yticks([-3, -2, 0, 2, 3])
    ax14.set_yticklabels(['Down', 'Bear Div', 'Neutral', 'Bull Div', 'Up'])
    ax14.set_title('ASI Swing Pattern Regime', fontsize=12, fontweight='bold')
    ax14.grid(True, alpha=grid_alpha)

    # 15. Volatility Regime
    ax15 = axes[14]
    vol_mapping = {'Low': 1, 'Normal': 2, 'High': 3, 'Very High': 4}
    vol_colors = {'Low': 'lightblue', 'Normal': 'blue', 'High': 'orange', 'Very High': 'red'}

    # Handle NaN values
    vol_numeric = master_df['volatility_regime'].map(vol_mapping).fillna(0)

    for vol, color in vol_colors.items():
        mask = master_df['volatility_regime'] == vol
        if mask.any():
            ax15.fill_between(x, 0, 5, where=mask, alpha=0.3, color=color)

    ax15.plot(x, vol_numeric, 'black', linewidth=1, alpha=0.5)
    ax15.set_ylabel('Vol Regime', fontsize=11)
    ax15.set_ylim(0, 5)
    ax15.set_yticks([1, 2, 3, 4])
    ax15.set_yticklabels(['Low', 'Normal', 'High', 'Very High'])
    ax15.set_xlabel('Bar Index', fontsize=11)
    ax15.set_title('Volatility Regime', fontsize=12, fontweight='bold')
    ax15.grid(True, alpha=grid_alpha)

    # Overall title
    fig.suptitle("Master Wilder's Technical Trading Systems - All Indicators",
                 fontsize=16, fontweight='bold', y=0.995)

    plt.tight_layout()
    plt.show()

    # Print final summary
    print("\n" + "="*80)
    print("MASTER INDICATORS SUMMARY - FINAL ANALYSIS")
    print("="*80)

    print(f"\nData Statistics:")
    print(f"  Total Bars: {len(master_df)}")
    print(f"  Date Range: {master_df['date'].iloc[0]} to {master_df['date'].iloc[-1]}")
    print(f"  Total Features: {len(master_df.columns)}")

    print(f"\nCurrent Values (Last Bar):")
    print(f"  Price: {master_df['close'].iloc[-1]:.5f}")
    print(f"  ASI: {master_df['asi'].iloc[-1]:.2f}")
    print(f"  KAMA(5): {master_df['kama_asi_5'].iloc[-1]:.2f}")
    print(f"  KAMA(10): {master_df['kama_asi_10'].iloc[-1]:.2f}")
    print(f"  ADX: {master_df['adx'].iloc[-1]:.2f}")
    print(f"  ATR: {master_df['atr_14'].iloc[-1]:.5f}")
    print(f"  Price RSI: {master_df['price_rsi'].iloc[-1]:.2f}")
    print(f"  ASI RSI: {master_df['asi_rsi'].iloc[-1]:.2f}")

    print(f"\nPosition Summary:")
    print(f"  Parabolic SAR: {'LONG' if master_df['psar_position'].iloc[-1] == 1 else 'SHORT'}")
    print(f"  Volatility System: {'LONG' if master_df['vi_position'].iloc[-1] == 1 else 'SHORT' if master_df['vi_position'].iloc[-1] == -1 else 'FLAT'}")
    print(f"  Momentum/TBP: {'LONG' if master_df['momentum_position'].iloc[-1] == 1 else 'SHORT' if master_df['momentum_position'].iloc[-1] == -1 else 'FLAT'}")
    print(f"  Reaction Trend: {'LONG' if master_df['reaction_position'].iloc[-1] == 1 else 'SHORT' if master_df['reaction_position'].iloc[-1] == -1 else 'FLAT'}")
    print(f"  Combined Signal: {master_df['combined_position_signal'].iloc[-1]:.3f}")

    print(f"\nMarket State:")
    print(f"  Swing Regime: {master_df['swing_regime'].iloc[-1]}")
    print(f"  Volatility Regime: {master_df['volatility_regime'].iloc[-1]}")
    print(f"  Trend Strength: {master_df['trend_strength'].iloc[-1]}")
    print(f"  Reaction Mode: {master_df['reaction_mode'].iloc[-1]}")

    # Signal alignment
    bullish_count = 0
    bearish_count = 0

    # Check each system
    if master_df['psar_position'].iloc[-1] == 1:
        bullish_count += 1
    else:
        bearish_count += 1

    if master_df['vi_position'].iloc[-1] == 1:
        bullish_count += 1
    elif master_df['vi_position'].iloc[-1] == -1:
        bearish_count += 1

    if master_df['momentum_position'].iloc[-1] == 1:
        bullish_count += 1
    elif master_df['momentum_position'].iloc[-1] == -1:
        bearish_count += 1

    if master_df['plus_di'].iloc[-1] > master_df['minus_di'].iloc[-1]:
        bullish_count += 1
    else:
        bearish_count += 1

    if master_df['asi'].iloc[-1] > master_df['kama_asi_5'].iloc[-1]:
        bullish_count += 1
    else:
        bearish_count += 1

    print(f"\nSignal Consensus:")
    print(f"  Bullish Signals: {bullish_count}")
    print(f"  Bearish Signals: {bearish_count}")

    if bullish_count > bearish_count + 2:
        print("  → STRONG BULLISH CONSENSUS")
    elif bullish_count > bearish_count:
        print("  → MODERATE BULLISH BIAS")
    elif bearish_count > bullish_count + 2:
        print("  → STRONG BEARISH CONSENSUS")
    elif bearish_count > bullish_count:
        print("  → MODERATE BEARISH BIAS")
    else:
        print("  → NEUTRAL/MIXED SIGNALS")

    print("\n" + "="*80)
    print("WILDER'S COMPLETE TECHNICAL TRADING SYSTEMS - ANALYSIS COMPLETE")
    print("="*80)

# Create the final comprehensive plot
plot_all_indicators_final(master_df)

# Final Comprehensive Plot - All Indicators as Subplots
def plot_all_indicators_final(master_df):
    """
    Create the final comprehensive visualization with price and all indicators as subplots.
    """

    # Define subplot layout - 15 rows for all major indicators
    fig, axes = plt.subplots(15, 1, figsize=(20, 45),
                            height_ratios=[3, 2, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.2, 1.2, 1.2, 1.2, 1.2, 1, 1])

    x = np.arange(len(master_df))

    # Define common style parameters
    grid_alpha = 0.3
    line_alpha = 0.8
    fill_alpha = 0.3

    # 1. Price Chart with Candlesticks
    ax1 = axes[0]
    for i in range(len(master_df)):
        color = 'g' if master_df['close'].iloc[i] >= master_df['open'].iloc[i] else 'r'
        ax1.plot([x[i], x[i]],
                [master_df['low'].iloc[i], master_df['high'].iloc[i]],
                color=color, linewidth=1, alpha=0.7)
        rect = Rectangle((x[i]-0.3,
                         min(master_df['open'].iloc[i], master_df['close'].iloc[i])),
                        0.6,
                        abs(master_df['close'].iloc[i] - master_df['open'].iloc[i]),
                        facecolor=color, alpha=0.5)
        ax1.add_patch(rect)

    ax1.set_ylabel('Price', fontsize=11)
    ax1.set_title('OHLC Price Chart', fontsize=12, fontweight='bold')
    ax1.grid(True, alpha=grid_alpha)

    # 2. ASI with KAMA(5) and KAMA(10)
    ax2 = axes[1]

    # Color code ASI based on swing points
    asi_colors = ['orange'] * len(master_df)
    for i in range(len(master_df)):
        if master_df['is_hsp'].iloc[i] == 1:
            asi_colors[i] = 'purple'
        elif master_df['is_lsp'].iloc[i] == 1:
            asi_colors[i] = 'blue'

    ax2.scatter(x, master_df['asi'], c=asi_colors, s=2, alpha=0.7, label='ASI')
    ax2.plot(x, master_df['kama_asi_5'], 'green', linewidth=2,
             label='KAMA(5)', alpha=0.9, linestyle='-')
    ax2.plot(x, master_df['kama_asi_10'], 'red', linewidth=2,
             label='KAMA(10)', alpha=0.9, linestyle='--')

    ax2.axhline(y=0, color='gray', linestyle='-', alpha=0.5)
    ax2.set_ylabel('ASI', fontsize=11)
    ax2.set_title('Accumulation Swing Index with KAMA', fontsize=12, fontweight='bold')
    ax2.legend(loc='upper left', fontsize=9)
    ax2.grid(True, alpha=grid_alpha)

    # 3. ASI Slope
    ax3 = axes[2]
    ax3.plot(x, master_df['asi_slope'], 'darkblue', linewidth=1.2, alpha=line_alpha)
    ax3.fill_between(x, 0, master_df['asi_slope'],
                     where=master_df['asi_slope'] > 0,
                     alpha=fill_alpha, color='green')
    ax3.fill_between(x, 0, master_df['asi_slope'],
                     where=master_df['asi_slope'] < 0,
                     alpha=fill_alpha, color='red')
    ax3.axhline(y=0, color='gray', linestyle='-', alpha=0.5)
    ax3.set_ylabel('ASI Slope', fontsize=11)
    ax3.set_title('ASI Slope (Momentum)', fontsize=12, fontweight='bold')
    ax3.grid(True, alpha=grid_alpha)

    # 4. Swing Point Slopes
    ax4 = axes[3]
    ax4.plot(x, master_df['slope_hsps'], 'purple', linewidth=1.5,
              label='HSP Slope', alpha=line_alpha)
    ax4.plot(x, master_df['slope_lsps'], 'blue', linewidth=1.5,
              label='LSP Slope', alpha=line_alpha)
    ax4.axhline(y=0, color='gray', linestyle='-', alpha=0.5)
    ax4.set_ylabel('Slope', fontsize=11)
    ax4.set_title('Swing Point Slopes', fontsize=12, fontweight='bold')
    ax4.legend(loc='upper left', fontsize=9)
    ax4.grid(True, alpha=grid_alpha)

    # 5. ADX and DI
    ax5 = axes[4]
    ax5.plot(x, master_df['plus_di'], 'green', linewidth=1.2,
             label='+DI', alpha=line_alpha)
    ax5.plot(x, master_df['minus_di'], 'red', linewidth=1.2,
             label='-DI', alpha=line_alpha)
    ax5.plot(x, master_df['adx'], 'blue', linewidth=1.5,
             label='ADX', alpha=0.9)
    ax5.axhline(y=25, color='gray', linestyle='--', alpha=0.5)
    ax5.set_ylabel('DMI', fontsize=11)
    ax5.set_title('Directional Movement Index', fontsize=12, fontweight='bold')
    ax5.legend(loc='upper left', fontsize=9, ncol=3)
    ax5.grid(True, alpha=grid_alpha)
    ax5.set_ylim(0, max(60, master_df['adx'].max() * 1.1))

    # 6. ATR (Volatility)
    ax6 = axes[5]
    ax6.plot(x, master_df['atr_14'], 'purple', linewidth=1.5, alpha=line_alpha)
    ax6.fill_between(x, 0, master_df['atr_14'], alpha=fill_alpha, color='purple')
    atr_mean = master_df['atr_14'][master_df['atr_14'] > 0].mean()
    ax6.axhline(y=atr_mean, color='gray', linestyle=':', alpha=0.5)
    ax6.set_ylabel('ATR', fontsize=11)
    ax6.set_title('Average True Range (Volatility)', fontsize=12, fontweight='bold')
    ax6.grid(True, alpha=grid_alpha)

    # 7. Price RSI
    ax7 = axes[6]
    ax7.plot(x, master_df['price_rsi'], 'blue', linewidth=1.2, alpha=line_alpha)
    ax7.axhline(y=70, color='red', linestyle='--', alpha=0.5)
    ax7.axhline(y=30, color='green', linestyle='--', alpha=0.5)
    ax7.axhline(y=50, color='gray', linestyle='-', alpha=0.3)
    ax7.fill_between(x, 70, 100, alpha=0.1, color='red')
    ax7.fill_between(x, 0, 30, alpha=0.1, color='green')
    ax7.set_ylabel('RSI', fontsize=11)
    ax7.set_ylim(0, 100)
    ax7.set_title('Price RSI', fontsize=12, fontweight='bold')
    ax7.grid(True, alpha=grid_alpha)

    # 8. ASI RSI
    ax8 = axes[7]
    ax8.plot(x, master_df['asi_rsi'], 'purple', linewidth=1.2, alpha=line_alpha)
    ax8.axhline(y=70, color='red', linestyle='--', alpha=0.5)
    ax8.axhline(y=30, color='green', linestyle='--', alpha=0.5)
    ax8.axhline(y=50, color='gray', linestyle='-', alpha=0.3)
    ax8.fill_between(x, 70, 100, alpha=0.1, color='red')
    ax8.fill_between(x, 0, 30, alpha=0.1, color='green')
    ax8.set_ylabel('RSI', fontsize=11)
    ax8.set_ylim(0, 100)
    ax8.set_title('ASI RSI', fontsize=12, fontweight='bold')
    ax8.grid(True, alpha=grid_alpha)

    # 9. Parabolic SAR Position
    ax9 = axes[8]
    psar_colors = ['green' if pos == 1 else 'red' for pos in master_df['psar_position']]
    ax9.bar(x, master_df['psar_position'], color=psar_colors, alpha=0.7, width=0.8)
    ax9.axhline(y=0, color='black', linestyle='-', linewidth=0.5)
    ax9.set_ylabel('Position', fontsize=11)
    ax9.set_ylim(-1.5, 1.5)
    ax9.set_title('Parabolic SAR Position', fontsize=12, fontweight='bold')
    ax9.grid(True, alpha=grid_alpha)

    # 10. Momentum Factor
    ax10 = axes[9]
    mf_colors = ['green' if val > 0 else 'red' for val in master_df['momentum_factor']]
    ax10.bar(x, master_df['momentum_factor'], color=mf_colors, alpha=0.7, width=0.8)
    ax10.axhline(y=0, color='black', linestyle='-', linewidth=1)
    ax10.set_ylabel('MF', fontsize=11)
    ax10.set_title('Momentum Factor', fontsize=12, fontweight='bold')
    ax10.grid(True, alpha=grid_alpha)

    # 11. TBP Position
    ax11 = axes[10]
    tbp_colors = ['green' if pos == 1 else 'red' if pos == -1 else 'gray'
                  for pos in master_df['momentum_position']]
    ax11.bar(x, master_df['momentum_position'], color=tbp_colors, alpha=0.7, width=0.8)
    ax11.axhline(y=0, color='black', linestyle='-', linewidth=0.5)
    ax11.set_ylabel('Position', fontsize=11)
    ax11.set_ylim(-1.5, 1.5)
    ax11.set_title('Momentum/TBP Position', fontsize=12, fontweight='bold')
    ax11.grid(True, alpha=grid_alpha)

    # 12. Reaction Trend Mode
    ax12 = axes[11]
    mode_numeric = np.array([1 if m == 'TREND' else 0 for m in master_df['reaction_mode']])
    ax12.fill_between(x, 0, mode_numeric, where=(mode_numeric == 1),
                     alpha=0.5, color='blue', step='mid')
    ax12.set_ylabel('Mode', fontsize=11)
    ax12.set_ylim(-0.1, 1.1)
    ax12.set_yticks([0, 1])
    ax12.set_yticklabels(['REACTION', 'TREND'])
    ax12.set_title('Reaction Trend Mode', fontsize=12, fontweight='bold')
    ax12.grid(True, alpha=grid_alpha)

    # 13. Combined Position Signal
    ax13 = axes[12]
    pos_colors = ['green' if val > 0 else 'red' if val < 0 else 'gray'
                  for val in master_df['combined_position_signal']]
    ax13.bar(x, master_df['combined_position_signal'],
             color=pos_colors, alpha=0.7, width=0.8)
    ax13.axhline(y=0, color='black', linestyle='-', linewidth=1)
    ax13.set_ylabel('Signal', fontsize=11)
    ax13.set_ylim(-1.2, 1.2)
    ax13.set_title('Combined Position Signal', fontsize=12, fontweight='bold')
    ax13.grid(True, alpha=grid_alpha)

    # 14. Swing Regime
    ax14 = axes[13]
    regime_mapping = {'Uptrend': 3, 'Bull_Div': 2, 'Bear_Div': -2, 'Downtrend': -3, '': 0}
    regime_colors = {'Uptrend': 'darkgreen', 'Bull_Div': 'lightgreen',
                     'Bear_Div': 'orange', 'Downtrend': 'darkred', '': 'gray'}

    regime_numeric = master_df['swing_regime'].map(regime_mapping)
    for regime, color in regime_colors.items():
        mask = master_df['swing_regime'] == regime
        if mask.any():
            ax14.fill_between(x, -4, 4, where=mask, alpha=0.3, color=color)

    ax14.plot(x, regime_numeric, 'black', linewidth=1, alpha=0.5)
    ax14.axhline(y=0, color='gray', linestyle='-', alpha=0.5)
    ax14.set_ylabel('Regime', fontsize=11)
    ax14.set_ylim(-4, 4)
    ax14.set_yticks([-3, -2, 0, 2, 3])
    ax14.set_yticklabels(['Down', 'Bear Div', 'Neutral', 'Bull Div', 'Up'])
    ax14.set_title('ASI Swing Pattern Regime', fontsize=12, fontweight='bold')
    ax14.grid(True, alpha=grid_alpha)

    # 15. Volatility Regime
    ax15 = axes[14]
    vol_mapping = {'Low': 1, 'Normal': 2, 'High': 3, 'Very High': 4}
    vol_colors = {'Low': 'lightblue', 'Normal': 'blue', 'High': 'orange', 'Very High': 'red'}

    # Handle NaN values
    vol_numeric = master_df['volatility_regime'].map(vol_mapping).fillna(0)

    for vol, color in vol_colors.items():
        mask = master_df['volatility_regime'] == vol
        if mask.any():
            ax15.fill_between(x, 0, 5, where=mask, alpha=0.3, color=color)

    ax15.plot(x, vol_numeric, 'black', linewidth=1, alpha=0.5)
    ax15.set_ylabel('Vol Regime', fontsize=11)
    ax15.set_ylim(0, 5)
    ax15.set_yticks([1, 2, 3, 4])
    ax15.set_yticklabels(['Low', 'Normal', 'High', 'Very High'])
    ax15.set_xlabel('Bar Index', fontsize=11)
    ax15.set_title('Volatility Regime', fontsize=12, fontweight='bold')
    ax15.grid(True, alpha=grid_alpha)

    # Overall title
    fig.suptitle("Master Wilder's Technical Trading Systems - All Indicators",
                 fontsize=16, fontweight='bold', y=0.995)

    plt.tight_layout()
    plt.show()

    # Print final summary
    print("\n" + "="*80)
    print("MASTER INDICATORS SUMMARY - FINAL ANALYSIS")
    print("="*80)

    print(f"\nData Statistics:")
    print(f"  Total Bars: {len(master_df)}")
    print(f"  Date Range: {master_df['date'].iloc[0]} to {master_df['date'].iloc[-1]}")
    print(f"  Total Features: {len(master_df.columns)}")

    print(f"\nCurrent Values (Last Bar):")
    print(f"  Price: {master_df['close'].iloc[-1]:.5f}")
    print(f"  ASI: {master_df['asi'].iloc[-1]:.2f}")
    print(f"  KAMA(5): {master_df['kama_asi_5'].iloc[-1]:.2f}")
    print(f"  KAMA(10): {master_df['kama_asi_10'].iloc[-1]:.2f}")
    print(f"  ADX: {master_df['adx'].iloc[-1]:.2f}")
    print(f"  ATR: {master_df['atr_14'].iloc[-1]:.5f}")
    print(f"  Price RSI: {master_df['price_rsi'].iloc[-1]:.2f}")
    print(f"  ASI RSI: {master_df['asi_rsi'].iloc[-1]:.2f}")

    print(f"\nPosition Summary:")
    print(f"  Parabolic SAR: {'LONG' if master_df['psar_position'].iloc[-1] == 1 else 'SHORT'}")
    print(f"  Volatility System: {'LONG' if master_df['vi_position'].iloc[-1] == 1 else 'SHORT' if master_df['vi_position'].iloc[-1] == -1 else 'FLAT'}")
    print(f"  Momentum/TBP: {'LONG' if master_df['momentum_position'].iloc[-1] == 1 else 'SHORT' if master_df['momentum_position'].iloc[-1] == -1 else 'FLAT'}")
    print(f"  Reaction Trend: {'LONG' if master_df['reaction_position'].iloc[-1] == 1 else 'SHORT' if master_df['reaction_position'].iloc[-1] == -1 else 'FLAT'}")
    print(f"  Combined Signal: {master_df['combined_position_signal'].iloc[-1]:.3f}")

    print(f"\nMarket State:")
    print(f"  Swing Regime: {master_df['swing_regime'].iloc[-1]}")
    print(f"  Volatility Regime: {master_df['volatility_regime'].iloc[-1]}")
    print(f"  Trend Strength: {master_df['trend_strength'].iloc[-1]}")
    print(f"  Reaction Mode: {master_df['reaction_mode'].iloc[-1]}")

    # Signal alignment
    bullish_count = 0
    bearish_count = 0

    # Check each system
    if master_df['psar_position'].iloc[-1] == 1:
        bullish_count += 1
    else:
        bearish_count += 1

    if master_df['vi_position'].iloc[-1] == 1:
        bullish_count += 1
    elif master_df['vi_position'].iloc[-1] == -1:
        bearish_count += 1

    if master_df['momentum_position'].iloc[-1] == 1:
        bullish_count += 1
    elif master_df['momentum_position'].iloc[-1] == -1:
        bearish_count += 1

    if master_df['plus_di'].iloc[-1] > master_df['minus_di'].iloc[-1]:
        bullish_count += 1
    else:
        bearish_count += 1

    if master_df['asi'].iloc[-1] > master_df['kama_asi_5'].iloc[-1]:
        bullish_count += 1
    else:
        bearish_count += 1

    print(f"\nSignal Consensus:")
    print(f"  Bullish Signals: {bullish_count}")
    print(f"  Bearish Signals: {bearish_count}")

    if bullish_count > bearish_count + 2:
        print("  → STRONG BULLISH CONSENSUS")
    elif bullish_count > bearish_count:
        print("  → MODERATE BULLISH BIAS")
    elif bearish_count > bullish_count + 2:
        print("  → STRONG BEARISH CONSENSUS")
    elif bearish_count > bullish_count:
        print("  → MODERATE BEARISH BIAS")
    else:
        print("  → NEUTRAL/MIXED SIGNALS")

    print("\n" + "="*80)
    print("WILDER'S COMPLETE TECHNICAL TRADING SYSTEMS - ANALYSIS COMPLETE")
    print("="*80)

# Create the final comprehensive plot
plot_all_indicators_final(master_df)